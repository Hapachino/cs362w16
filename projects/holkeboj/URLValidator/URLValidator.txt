[URLValidator.txt]
Oregon State University
Computer Science 362
Course Project Part B report

Group Members:
Jack Holkeboer - holkeboj@onid.oregonstate.edu
Kyle Collins - collikyl@oregonstate.edu
Shaine Afzal - afzals@oregostate.edu


All tests described here can be found in src/UrlValidatorTest.java

HOW WE DIVIDED UP THE WORK AS A TEAM
When we read the assignment instructions we noticed a natural division between three types of testing - manual, partition, and programmatic.  We decided that since we had 3 team members, each one of us would concentrate on one of these areas.  We started out working separately on each area, running our tests and finding bugs.  Then we came together and compared our results.  In most cases, bugs that were found in one testing methodology were also found in the others.  In other cases, we were able to point out elements of each others' tests that could be improved.  Once we agreed upon what the bugs were, we then simultaneously dug into the UrlValidator source code to isolate the causes of them.

USE OF AGAN'S PRINCIPLES
The main one of Agan's principles that was helpful to us was Rule #1: Understand the System.
Just as we did with Dominion, it is important to understand the rules your are dealing with.  Otherwise it is impossible to debug effectively.  For Dominion, this meant playing the game and understading what the rules are (i.e. what happens when you play each card).  For UrlValidator, we first had to understand what makes a URL valid in the first place.  This involved first reading online about URL validity and then thoroughly examining the UrlValidatorCorrect code to see how the program is supposed to work.  We did this when we completed the Project Part A.


EXPLANATION OF METHODOLOGY

Manual Tests:
-------------------------
[explain manual testing method here]


Partition Tests:
-------------------------
[explain partition testing method here]


Programming based tests:
-------------------------
We used random testing in order to generate the widest possible variety of test cases.  We used the ResultPair object that is supplied with the URLValidator code, which contains a string of text (the property "item") and a boolean value (the property "valid").  Each pair is meant to be a certain part of the URL.  

The idea behind constructing tests this way is that each URL segment is either valid or invalid.  If a URL string contains one invalid segment, the entire URL should be invalidated.  Therefore, we take the "and" value of the validity of each resultPair like this:

    // How we derive URL validity
    Boolean testURLValidity = schemeValidity && addressValidity && portValidity
				   && pathValidity && queryStringValidity;
                   
Each validity boolean corresponds to one part of the URL:
    - Scheme (http, ftp, etc)
    - Address (e.g. yahoo.com, www.google.com, bbc.co.uk, etc)
    - Port (e.g. no port, :80, :63353, etc)
    - Path (e.g. /path, /path1/path2/file.txt, etc)
    - Query String (e.g. ?value=1)

To generate a random test case, first we supply a list of possible strings for each parameter.  You can see these in our UrlValidatorTest.java file in the testIsValid() function.  We then choose a random element from each list and concatenate them.  Parameters that are not mandatory will have an empty string ("") as one of the possible options, so not every test URL will contain every part.  The code that generates our test cases looks like this:

        // generate test cases
	   for(int i = 0;i<numberOfTests;i++)
	   {
		   // get random scheme
		   int randomSchemeIndex = generator.nextInt(testSchemes.length);
		   String scheme = testSchemes[randomSchemeIndex].item;
		   Boolean schemeValidity = testSchemes[randomSchemeIndex].valid;
		   
		   // get random address
		   int randomAddressIndex = generator.nextInt(testAddresses.length);
		   String address = testAddresses[randomAddressIndex].item;
		   Boolean addressValidity = testAddresses[randomAddressIndex].valid;	
		   
		   // get random port
		   int randomPortIndex = generator.nextInt(testPorts.length);
		   String port = testPorts[randomPortIndex].item;
		   Boolean portValidity = testPorts[randomPortIndex].valid;
		   
		   // get random path
		   int randomPathIndex = generator.nextInt(testPaths.length);
		   String path = testPaths[randomPathIndex].item;
		   Boolean pathValidity = testPaths[randomPathIndex].valid;	
		   
		   // get random query string
		   int randomQueryStringIndex = generator.nextInt(testQueryStrings.length);
		   String queryString = testQueryStrings[randomQueryStringIndex].item;
		   Boolean queryStringValidity = testQueryStrings[randomQueryStringIndex].valid;
		   
		   // build test case
		   String testURL = scheme + address + port + path + queryString;
		   Boolean testURLValidity = schemeValidity && addressValidity && portValidity
				   && pathValidity && queryStringValidity;
		   
		   // test the test case
		   UrlValidator urlVal = new UrlValidator(null, null, UrlValidator.ALLOW_LOCAL_URLS);
		   boolean result = urlVal.isValid(testURL);
		   if (result != testURLValidity) {
			   System.out.format("Failed for URL %s\n", testURL);
			   testsFailed += 1;
		   }
	   }

The benefit of this approach is that it allows us to run a large number of tests.  We set it to run 10,000 tests and on average had around 340 tests failing.  This lets us know that the program is accurate the majority of the time but there are definitely some buggy cases that come up consistently.  

We found that although random testing is great for achiving broad code coverage, it was easier for us to find bugs by constructing manual and partition cases and concentrating on the differences between those.  The same bugs happen in the random tests, but there is extra work required to sift throught the results, detect patterns, and figure out what is causing them.



DESCRIPTION OF BUGS FOUND

Bug #1: isValid() invalidates any URL with a question mark
-------------------------
How it was detected: 
In our manual and programmatic tests, we noticed a pattern that every url with a question mark was invalidated, even if it was otherwise valid.  Question marks are a common part of URLs so we knew this was a significant bug.

Cause: 
The query string part of the url is validated in isValid by this code in UrlValidator.java:
        
        // line 341
        if (!isValidQuery(urlMatcher.group(PARSE_URL_QUERY))) {
            return false;
        }

isValidQuery() checks the query string by comparing it to the following regular expression:

    // line 151
    private static final String QUERY_REGEX = "^(.*)$";

We can see that this regular expression does not include a question mark, which means that any URL with a question mark will not match the pattern and therefore be invalidated.  


Bug #2: isValid() does not detect invalid IP addresses
-------------------------
How it was found:  We noticed that in our programmatic tests, all tests with an invalid IP address were failing.  Any IP address with a number over 255 is invalid.  Here are some examples of otherwise valid URLS with invalid IP addresses that should have been invalidated:

ftp://255.256.255.255:80/i12iro3i
http://300.168.0.110:0/testpath
http://300.168.0.110:80/testpath1/testpath2

To confirm this, we added the following test to the manual tests, to confirm that this wasn't caused by some other bug:

    System.out.println(urlVal.isValid("http://256.256.256.256"));

The above test evaluated to true when it should have been false.  Since everything else about the URL is valid, we can confirm that this is caused by a bug in IP address evaluation.

Cause:
The following lines of code show where the "authority" (combination of hostname and port) is checked by isValid()

        // check if authority is hostname or IP address:
        // try a hostname first since that's much more likely
        DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
        if (!domainValidator.isValid(hostLocation)) {
            // try an IP address
            InetAddressValidator inetAddressValidator =
                InetAddressValidator.getInstance();
            if (!inetAddressValidator.isValid(hostLocation)) {
                // isn't either one, so the URL is invalid
                return false;
            }
        }

We can see that first it checks to see if the host is valid, and if it's not a vaid hostname, it then uses InetAddressValidator to check if it's a valid IP address.

The faulty section of the code starts on line 94 in InetAddressValidator.java:

            if (iIpSegment > 255) {
                
            	return true;
            	
            }

This is wrong because any IP segment greater than 255 is not valid.  This could be fixed by setting this condition to return false instead of true.

Bug #3: isValid() does not detect invalid Top Level Domains
-------------------------
How it was found:
We noticed in our programmatic tests that a lot of urls with invalid top level domains were failing.  For example, the url "http://google.kjfwoei" was evaluating to true.  

To investigated further, we added the following manual tests:

	   System.out.println(urlVal.isValid("http://google.kjfwoei"));
	   System.out.println(urlVal.isValid("http://google.BLAHBLAH"));
	   System.out.println(urlVal.isValid("http://www.google.123HFJ"));

These were all expected to return false, but instead they all returned true.  Since these urls are valid except for the TLD, we can confirm that this is an issue with the TLD validation

Cause:
Domain validation is handled by the DomainValidator class.  We focused on this class file to isolate the problem.

We then focused on the isValidTld() function contained within DomainValidator.  This is the part of the code that evaluates the TLD, starting on line 153 in DomainValidator.java:

    public boolean isValidTld(String tld) {
        if(allowLocal && isValidLocalTld(tld)) {
           return true;
        }
        return isValidInfrastructureTld(tld)
                || isValidGenericTld(tld)
                || isValidCountryCodeTld(tld);
    }

We notice that isValidLocalTld() is only evaluated if allowLocal is true, and we are running with the ALLOW_LOCAL_URLS option.  So we were able to isolate this effect to the isValidLocalTld function, starting on line 202 in DomainValidator.java:

    public boolean isValidLocalTld(String iTld) {
        // the bug is in this line
    	return !LOCAL_TLD_LIST.contains(chompLeadingDot(iTld.toLowerCase()));
    }

The bug here is the exclamation mark before the evaluation of LOCAL_TLD_LIST.contains().
In the other similar functions, this exclamation mark is not present.  This is important beacuse it reverses the Boolean value we are expecting.  In other words, if our TLD is not in the list, it will return true, which is the opposite of the behavior we want.  When we remove this exclamation point, we get the expected behavior.
