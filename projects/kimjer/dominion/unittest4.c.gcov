        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:#include <time.h>
        -:    8:#include <stdlib.h>
        -:    9:#include <assert.h>
        -:   10:#define NUMCARDS 10
        -:   11:
function main called 1 returned 100% blocks executed 73%
        1:   12:int main() {
        -:   13:
        -:   14:	struct gameState G;
        -:   15:
        1:   16:	int seed = 1000;
        -:   17:	int t1, t2, t3, t4;
        1:   18:	int numPlayers = 4;
        1:   19:	int k[10] = {adventurer, council_room, feast, gardens, mine, remodel, smithy, village, baron, great_hall};
        1:   20:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        1:   21:	G.whoseTurn = 0;
        1:   22:	t1 = G.whoseTurn;
        -:   23:
        1:   24:	endTurn(&G);
call    0 returned 100%
        1:   25:	t1 = G.whoseTurn;
        1:   26:	assert(t1 == 1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   27:
        1:   28:	endTurn(&G);
call    0 returned 100%
        1:   29:	t1 = G.whoseTurn;
        1:   30:	assert(t1 == 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   31:
        1:   32:	endTurn(&G);
call    0 returned 100%
        1:   33:	t1 = G.whoseTurn;
        1:   34:	assert(t1 == 3);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   35:
        1:   36:	endTurn(&G);
call    0 returned 100%
        1:   37:	t1 = G.whoseTurn;
        1:   38:	assert(t1 == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:   39:	return 0;
        -:   40:}
        -:   41:
        -:   42:
        -:   43:// int endTurn(struct gameState *state) {
        -:   44://   int k;
        -:   45://   int i;
        -:   46://   int currentPlayer = whoseTurn(state);
        -:   47:  
        -:   48://   //Discard hand
        -:   49://   for (i = 0; i < state->handCount[currentPlayer]; i++){
        -:   50://     state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
        -:   51://     state->hand[currentPlayer][i] = -1;//Set card to -1
        -:   52://   }
        -:   53://   state->handCount[currentPlayer] = 0;//Reset hand count
        -:   54:    
        -:   55://   //Code for determining the player
        -:   56://   if (currentPlayer < (state->numPlayers - 1)){ 
        -:   57://     state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:   58://   }
        -:   59://   else{
        -:   60://     state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:   61://   }
        -:   62:
        -:   63://   state->outpostPlayed = 0;
        -:   64://   state->phase = 0;
        -:   65://   state->numActions = 1;
        -:   66://   state->coins = 0;
        -:   67://   state->numBuys = 1;
        -:   68://   state->playedCardCount = 0;
        -:   69://   state->handCount[state->whoseTurn] = 0;
        -:   70:
        -:   71://   //int k; move to top
        -:   72://   //Next player draws hand
        -:   73://   for (k = 0; k < 5; k++){
        -:   74://     drawCard(state->whoseTurn, state);//Draw a card
        -:   75://   }
        -:   76:
        -:   77://   //Update money
        -:   78://   updateCoins(state->whoseTurn, state , 0);
        -:   79:
        -:   80://   return 0;
        -:   81:// }
