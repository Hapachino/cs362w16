        -:    0:Source:villagetest.c
        -:    0:Graph:villagetest.gcno
        -:    0:Data:villagetest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include "cardFunctions.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <assert.h>
        -:    9:
        -:   10:
        -:   11://random hand with smithy at the end
function createRandomHand called 4 returned 100% blocks executed 100%
        4:   12:int createRandomHand(int *k, int max) 
        -:   13:{
        -:   14:	int j;
       20:   15:	for(j = 0; j < max-1; j++) 
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   16:	{
       16:   17:		k[j] = (rand()%15);
call    0 returned 100%
        -:   18:	}
        4:   19:	k[j] = smithy;
        4:   20:}
        -:   21:
        -:   22://random hand with smithy at the end
function createRandomDeck called 4 returned 100% blocks executed 100%
        4:   23:int createRandomDeck(int *k, int max) 
        -:   24:{
        -:   25:	int j;
     1984:   26:	for(j = 0; j < max; j++) 
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   27:	{
     1980:   28:		k[j] = (rand()%15);
call    0 returned 100%
        -:   29:	}
        4:   30:}
        -:   31:
function setDiscardDeck called 4 returned 100% blocks executed 100%
        4:   32:int setDiscardDeck(int *k, int max) {
        -:   33:	int i;
     2004:   34:	for(i = 0; i < max; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   35:	{
     2000:   36:		k[i] = -1;
        -:   37:	}
        4:   38:}
        -:   39:
function main called 1 returned 100% blocks executed 78%
        1:   40:int main() {
        1:   41:	srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:   42:	struct gameState G;
        -:   43:	struct infosStruct infos;
        1:   44:	int k[] = {5, 6, 7, 8, 9, 10, 11, 12, 13, 14};	
        1:   45:	int numPlayers = 4;
        -:   46:	int handCountBefore, handCountAfter;
        -:   47:	int deckCountBefore, deckCountAfter;
        1:   48:	int curPlayer, p1 = 0, p2 = 1, p3 = 2, p4 = 3;
        -:   49:	int i;
        1:   50:	int seed = 1000;
        1:   51:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        1:   52:	G.numPlayers = numPlayers;
        1:   53:	G.whoseTurn = 0;
        1:   54:	infos.currentPlayer = 0;
        1:   55:	infos.handPos = 4;
        -:   56:	int numActions1, numActions2;
        -:   57:	int numCards1, numCards2;
        -:   58:	int numDeck1, numDeck2;
        -:   59:	int numHand1, numHand2;
        -:   60:
        1:   61:	int handCount = 5;
        1:   62:	int deckCount = MAX_DECK - handCount;
        1:   63:	createRandomHand(G.hand[p1], handCount);
call    0 returned 100%
        1:   64:	createRandomHand(G.hand[p2], handCount);
call    0 returned 100%
        1:   65:	createRandomHand(G.hand[p3], handCount);
call    0 returned 100%
        1:   66:	createRandomHand(G.hand[p4], handCount);
call    0 returned 100%
        -:   67:
        1:   68:	G.handCount[p1] = handCount;
        1:   69:	G.handCount[p2] = handCount;	
        1:   70:	G.handCount[p3] = handCount;	
        1:   71:	G.handCount[p4] = handCount;
        -:   72:
        1:   73:	createRandomDeck(G.deck[p1], deckCount);
call    0 returned 100%
        1:   74:	createRandomDeck(G.deck[p2], deckCount);
call    0 returned 100%
        1:   75:	createRandomDeck(G.deck[p3], deckCount);
call    0 returned 100%
        1:   76:	createRandomDeck(G.deck[p4], deckCount);
call    0 returned 100%
        -:   77:
        1:   78:	G.deckCount[p1] = deckCount;
        1:   79:	G.deckCount[p2] = deckCount;	
        1:   80:	G.deckCount[p3] = deckCount;	
        1:   81:	G.deckCount[p4] = deckCount;
        -:   82:
        1:   83:	setDiscardDeck(G.discard[p1], MAX_DECK);
call    0 returned 100%
        1:   84:	setDiscardDeck(G.discard[p2], MAX_DECK);
call    0 returned 100%
        1:   85:	setDiscardDeck(G.discard[p3], MAX_DECK);
call    0 returned 100%
        1:   86:	setDiscardDeck(G.discard[p4], MAX_DECK);
call    0 returned 100%
        -:   87:
        1:   88:	G.discardCount[p1] = 0;
        1:   89:	G.discardCount[p2] = 0;	
        1:   90:	G.discardCount[p3] = 0;	
        1:   91:	G.discardCount[p4] = 0;
        -:   92:
        -:   93:
        -:   94://testing current player
        1:   95:	numActions1 = G.numActions;
        1:   96:	numHand1 = G.handCount[p1];
        1:   97:	numDeck1 = G.deckCount[p1];
        1:   98:	effectVillage(&G, &infos);
call    0 returned 100%
        -:   99:
        1:  100:	numHand2 = G.handCount[p1];
        1:  101:	numDeck2 = G.deckCount[p1];
        1:  102:	numActions2 = G.numActions;	
        1:  103:	assert(numActions1 +2 == numActions2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  104:	assert(numDeck1 -1 == numDeck2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  105:	//assert(numHand1 +1 == numHand2);
        -:  106:	
        1:  107:	endTurn(&G);
call    0 returned 100%
        1:  108:	assert(G.numActions == numActions1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  109:
        -:  110:	//testing for player 2
        1:  111:	infos.currentPlayer = 0;
        1:  112:	numHand1 = G.handCount[p2];
        1:  113:	numDeck1 = G.deckCount[p2];
        1:  114:	effectVillage(&G, &infos);
call    0 returned 100%
        -:  115:
        1:  116:	numHand2 = G.handCount[p2];
        1:  117:	numDeck2 = G.deckCount[p2];
        1:  118:	assert(numDeck1 == numDeck2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  119:	assert(numHand1 == numHand2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  120:
        -:  121://testing for player 3
        1:  122:	infos.currentPlayer = 0;
        1:  123:	numHand1 = G.handCount[p3];
        1:  124:	numDeck1 = G.deckCount[p3];
        1:  125:	effectVillage(&G, &infos);
call    0 returned 100%
        -:  126:
        1:  127:	numHand2 = G.handCount[p3];
        1:  128:	numDeck2 = G.deckCount[p3];
        1:  129:	assert(numDeck1 == numDeck2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  130:	assert(numHand1 == numHand2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  131:
        -:  132://testing for player 4
        1:  133:	infos.currentPlayer = 0;
        1:  134:	numHand1 = G.handCount[p4];
        1:  135:	numDeck1 = G.deckCount[p4];
        1:  136:	effectVillage(&G, &infos);
call    0 returned 100%
        -:  137:
        1:  138:	numHand2 = G.handCount[p4];
        1:  139:	numDeck2 = G.deckCount[p4];
        1:  140:	assert(numDeck1 == numDeck2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  141:	assert(numHand1 == numHand2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  142:
        -:  143:
        1:  144:	return 0;
        -:  145:}
        -:  146:
        -:  147:
        -:  148:
        -:  149:// int effectVillage(struct gameState *state, struct infosStruct *infos)
        -:  150:// {
        -:  151:
        -:  152://   int currentPlayer= infos->currentPlayer;
        -:  153:
        -:  154://   int handPos = infos->handPos;
        -:  155://   //+1 Card
        -:  156://   drawCard(currentPlayer, state);
        -:  157:
        -:  158://   //+2 Actions
        -:  159://   state->numActions = state->numActions + 2;
        -:  160:
        -:  161://   //discard played card from hand
        -:  162://   discardCard(handPos, currentPlayer, state, 0);
        -:  163://   return 0;
        -:  164:// }
        -:  165:
