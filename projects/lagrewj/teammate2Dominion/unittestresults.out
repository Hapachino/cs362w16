TESTING updateCoins() first coppers and silvers:

Test player 0 with 5 copper(s), 0 silver(s), and 6 bonus.
G.coins = 11, expected = 11

Test player 0 with 4 copper(s), 1 silver(s), and 5 bonus.
G.coins = 11, expected = 11

Test player 0 with 3 copper(s), 2 silver(s), and 8 bonus.
G.coins = 15, expected = 15

Test player 0 with 2 copper(s), 3 silver(s), and 0 bonus.
G.coins = 8, expected = 8

Test player 0 with 1 copper(s), 4 silver(s), and 5 bonus.
G.coins = 14, expected = 14

Test player 0 with 0 copper(s), 5 silver(s), and 0 bonus.
G.coins = 10, expected = 10

Test player 1 with 5 copper(s), 0 silver(s), and 2 bonus.
G.coins = 7, expected = 7

Test player 1 with 4 copper(s), 1 silver(s), and 6 bonus.
G.coins = 12, expected = 12

Test player 1 with 3 copper(s), 2 silver(s), and 1 bonus.
G.coins = 8, expected = 8

Test player 1 with 2 copper(s), 3 silver(s), and 4 bonus.
G.coins = 12, expected = 12

Test player 1 with 1 copper(s), 4 silver(s), and 8 bonus.
G.coins = 17, expected = 17

Test player 1 with 0 copper(s), 5 silver(s), and 4 bonus.
G.coins = 14, expected = 14
TESTING updateCoins() with coppers and golds:

Test player 0 with 5 copper(s), 0 gold(s), and 3 bonus.
G.coins = 8, expected = 8

Test player 0 with 4 copper(s), 1 gold(s), and 9 bonus.
G.coins = 16, expected = 16

Test player 0 with 3 copper(s), 2 gold(s), and 2 bonus.
G.coins = 11, expected = 11

Test player 0 with 2 copper(s), 3 gold(s), and 1 bonus.
G.coins = 12, expected = 12

Test player 0 with 1 copper(s), 4 gold(s), and 4 bonus.
G.coins = 17, expected = 17

Test player 0 with 0 copper(s), 5 gold(s), and 5 bonus.
G.coins = 20, expected = 20

Test player 1 with 5 copper(s), 0 gold(s), and 1 bonus.
G.coins = 6, expected = 6

Test player 1 with 4 copper(s), 1 gold(s), and 5 bonus.
G.coins = 12, expected = 12

Test player 1 with 3 copper(s), 2 gold(s), and 5 bonus.
G.coins = 14, expected = 14

Test player 1 with 2 copper(s), 3 gold(s), and 2 bonus.
G.coins = 13, expected = 13

Test player 1 with 1 copper(s), 4 gold(s), and 8 bonus.
G.coins = 21, expected = 21

Test player 1 with 0 copper(s), 5 gold(s), and 8 bonus.
G.coins = 23, expected = 23
All tests passed!

TESTING fullDeckCount():

Testing for Player 0:
Adding the following to the
deck:         5 coppers
hand:         10 golds
discard pile: 2 provinces
hand:         3 smithys
discard pile: 4 tributes
deck:         5 embargos
Test results:
estate result: 3, expected: 3
copper result: 7, expected: 7
updated copper result: 12, expected: 12
gold result: 10, expected: 10
province result: 2, expected: 2
smithy result: 3, expected: 3
tribute result: 4, expected: 4
embargo result: 5, expected: 5

Testing for Player 1:
Adding the following to the
deck:         5 coppers
hand:         10 golds
discard pile: 2 provinces
hand:         3 smithys
discard pile: 4 tributes
deck:         5 embargos
Test results:
estate result: 3, expected: 3
copper result: 7, expected: 7
updated copper result: 12, expected: 12
gold result: 10, expected: 10
province result: 2, expected: 2
smithy result: 3, expected: 3
tribute result: 4, expected: 4
embargo result: 5, expected: 5

Testing for Player 2:
Adding the following to the
deck:         5 coppers
hand:         10 golds
discard pile: 2 provinces
hand:         3 smithys
discard pile: 4 tributes
deck:         5 embargos
Test results:
estate result: 3, expected: 3
copper result: 7, expected: 7
updated copper result: 12, expected: 12
gold result: 10, expected: 10
province result: 2, expected: 2
smithy result: 3, expected: 3
tribute result: 4, expected: 4
embargo result: 5, expected: 5

All tests successful!

TESTING isGameOver():
Game over = 1
Test #1: Nothing changed
Game is over: 0, expected: 0

Test 2: 0 Provinces
Game is over: 1, expected: 1

Test 3: 1 Empty pile
Game is over: 0, expected: 0

Test 4: 2 empty piles
Game is over: 0, expected: 0

Test 5: 3 empty piles
Game is over: 1, expected: 1

All tests passed!

TESTING scoreFor():

Test 1 - Player 0:
Putting in the discard pile:
    5 duchy
    3 provinces
    1 great halls
    2 gardens
    1 curses
deckCount: 5
discardCount: 8
handCount: 5
Player 0 score: 25, expected: 38

Test 2 - Player 1:
All cards in deck, no additional card changes:
deckCount: 10
discardCount: 0
handCount: 0
Player 1 score: 0, expected: 3

2/2 test(s) failed!
----------------- Testing Card: smithy ----------------
Checking status before player buy...
After status created


 2nd testcard1.c test for Smithy
Begin Testing Smithy Again!
Player 1 Test -- Draw Smithy in hand
Test 1 Passed -- card in player's hand.
Position 0, Card: 4
Position 1, Card: 4
Position 2, Card: 4
Position 3, Card: 4
Position 4, Card: 4
DECK COUNTED
DISCARD COUNT -- SHOULD BE 0
Test 2 Passed -- Discard Successful. Count successful.
Position 0, card: 1
Position 1, card: 4
Position 2, card: 1
Position 3, card: 4
Position 4, card: 1
Position 5, card: 13
Smithy Granted Hand Count: 6
Before Smithy in Hand, Hand Count: 5
Test 4 Failed: Smithy did not add expected number of cards to hand.
Expected Hand Count: 9
Actual Result: 8
Testing Card Discard.
Test 5 passed -- Discard test and check passed.
Checking expected seed state.
Position 0 Deck Card: 4
Position 1 Deck Card: 4
Position 2 Deck Card: 4
Position 3 Deck Card: 4
Position 4 Deck Card: 4
Test 6 failed. Check code or change seed.
Checking hand and seed state.
Player 1 Test Completed.
------------------------

Player 2 Tests ----- 

DECK RECOUNT
Position 0, Card: 4
Position 1, Card: 1
Position 2, Card: 4
Position 3, Card: 4
Position 4, Card: 4
Position 5, Card: 1
Position 6, Card: 1
Position 7, Card: 4
Position 8, Card: 4
Position 9, Card: 4
Player has 10 card count Test.
Player has proper number of cards.
Smithy properly granted to player and player card count incremented.


------------------------
Smithy Test Summary
------------------------
One or more tests failed. playSmithy function has errors.
Smithy card did not work properly.
Smithy gave: 8
Expected: 9
End of Smithy test
----------------- Testing card: Adventurer ----------------
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 527 After: 528
ERROR 2: Hand count difference! Before: 3 After: 6
ERROR 3: Not enough treasure cards added to hand. Before: 16 After: 1
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 154 After: 155
ERROR 2: Hand count difference! Before: 336 After: 351
ERROR 3: Not enough treasure cards added to hand. Before: 62 After: 48
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 344 After: 345
ERROR 2: Hand count difference! Before: 109 After: 120
ERROR 3: Not enough treasure cards added to hand. Before: 73 After: 60
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 655 After: 656
ERROR 2: Hand count difference! Before: 243 After: 288
ERROR 3: Not enough treasure cards added to hand. Before: 103 After: 93
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 554 After: 555
ERROR 2: Hand count difference! Before: 409 After: 412
ERROR 3: Not enough treasure cards added to hand. Before: 155 After: 146
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 693 After: 694
ERROR 2: Hand count difference! Before: 207 After: 208
ERROR 3: Not enough treasure cards added to hand. Before: 179 After: 171
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 298 After: 299
ERROR 2: Hand count difference! Before: 438 After: 459
ERROR 3: Not enough treasure cards added to hand. Before: 224 After: 217
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 774 After: 775
ERROR 2: Hand count difference! Before: 33 After: 46
ERROR 3: Not enough treasure cards added to hand. Before: 231 After: 227
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 652 After: 653
ERROR 2: Hand count difference! Before: 103 After: 106
ERROR 3: Not enough treasure cards added to hand. Before: 242 After: 239
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 298 After: 299
ERROR 2: Hand count difference! Before: 169 After: 204
ERROR 3: Not enough treasure cards added to hand. Before: 260 After: 259
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 631 After: 632
ERROR 2: Hand count difference! Before: 116 After: 117
ERROR 3: Not enough treasure cards added to hand. Before: 270 After: 270
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 472 After: 473
ERROR 2: Hand count difference! Before: 467 After: 468
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 434 After: 435
ERROR 2: Hand count difference! Before: 3 After: 20
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 741 After: 742
ERROR 2: Hand count difference! Before: 495 After: 500
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 619 After: 620
ERROR 2: Hand count difference! Before: 295 After: 334
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 168 After: 169
ERROR 2: Hand count difference! Before: 237 After: 240
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 560 After: 561
ERROR 2: Hand count difference! Before: 159 After: 160
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 139 After: 140
ERROR 2: Hand count difference! Before: 442 After: 441
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 585 After: 586
ERROR 2: Hand count difference! Before: 171 After: 170
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 352 After: 353
ERROR 2: Hand count difference! Before: 330 After: 345
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 297 After: 298
ERROR 2: Hand count difference! Before: 146 After: 147
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 616 After: 617
ERROR 2: Hand count difference! Before: 435 After: 440
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 581 After: 582
ERROR 2: Hand count difference! Before: 79 After: 114
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 168 After: 169
ERROR 2: Hand count difference! Before: 58 After: 63
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 712 After: 713
ERROR 2: Hand count difference! Before: 83 After: 90
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 415 After: 416
ERROR 2: Hand count difference! Before: 414 After: 417
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 229 After: 230
ERROR 2: Hand count difference! Before: 361 After: 366
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 313 After: 314
ERROR 2: Hand count difference! Before: 72 After: 79
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 205 After: 206
ERROR 2: Hand count difference! Before: 30 After: 71
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 424 After: 425
ERROR 2: Hand count difference! Before: 78 After: 93
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 464 After: 465
ERROR 2: Hand count difference! Before: 66 After: 67
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 404 After: 405
ERROR 2: Hand count difference! Before: 481 After: 512
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 116 After: 117
ERROR 2: Hand count difference! Before: 311 After: 380
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 308 After: 309
ERROR 2: Hand count difference! Before: 338 After: 337
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 238 After: 239
ERROR 2: Hand count difference! Before: 342 After: 363
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 559 After: 560
ERROR 2: Hand count difference! Before: 352 After: 365
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 473 After: 474
ERROR 2: Hand count difference! Before: 104 After: 115
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 495 After: 496
ERROR 2: Hand count difference! Before: 460 After: 469
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 374 After: 375
ERROR 2: Hand count difference! Before: 322 After: 323
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 458 After: 459
ERROR 2: Hand count difference! Before: 464 After: 467
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 635 After: 636
ERROR 2: Hand count difference! Before: 129 After: 136
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 618 After: 619
ERROR 2: Hand count difference! Before: 460 After: 473
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 588 After: 589
ERROR 2: Hand count difference! Before: 127 After: 130
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 481 After: 482
ERROR 2: Hand count difference! Before: 444 After: 473
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 861 After: 862
ERROR 2: Hand count difference! Before: 435 After: 450
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 604 After: 605
ERROR 2: Hand count difference! Before: 151 After: 174
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 410 After: 411
ERROR 2: Hand count difference! Before: 201 After: 206
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 798 After: 799
ERROR 2: Hand count difference! Before: 454 After: 463
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 318 After: 319
ERROR 2: Hand count difference! Before: 415 After: 426
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 448 After: 449
ERROR 2: Hand count difference! Before: 23 After: 24
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 232 After: 233
ERROR 2: Hand count difference! Before: 435 After: 446
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 285 After: 286
ERROR 2: Hand count difference! Before: 228 After: 243
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 560 After: 561
ERROR 2: Hand count difference! Before: 377 After: 404
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 731 After: 732
ERROR 2: Hand count difference! Before: 265 After: 278
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 809 After: 810
ERROR 2: Hand count difference! Before: 161 After: 208
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 473 After: 474
ERROR 2: Hand count difference! Before: 72 After: 77
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 514 After: 515
ERROR 2: Hand count difference! Before: 35 After: 62
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 338 After: 339
ERROR 2: Hand count difference! Before: 204 After: 231
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 792 After: 793
ERROR 2: Hand count difference! Before: 349 After: 364
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 60 After: 61
ERROR 2: Hand count difference! Before: 419 After: 420
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 333 After: 334
ERROR 2: Hand count difference! Before: 36 After: 53
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 396 After: 397
ERROR 2: Hand count difference! Before: 185 After: 190
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 569 After: 570
ERROR 2: Hand count difference! Before: 179 After: 178
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 722 After: 723
ERROR 2: Hand count difference! Before: 234 After: 249
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 536 After: 537
ERROR 2: Hand count difference! Before: 362 After: 407
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 853 After: 854
ERROR 2: Hand count difference! Before: 353 After: 414
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 208 After: 209
ERROR 2: Hand count difference! Before: 50 After: 53
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 64 After: 65
ERROR 2: Hand count difference! Before: 411 After: 480
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 531 After: 532
ERROR 2: Hand count difference! Before: 356 After: 381
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 463 After: 464
ERROR 2: Hand count difference! Before: 361 After: 372
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 232 After: 233
ERROR 2: Hand count difference! Before: 366 After: 399
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 550 After: 551
ERROR 2: Hand count difference! Before: 432 After: 447
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 818 After: 819
ERROR 2: Hand count difference! Before: 341 After: 348
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 937 After: 938
ERROR 2: Hand count difference! Before: 347 After: 356
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 939 After: 940
ERROR 2: Hand count difference! Before: 51 After: 60
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 765 After: 766
ERROR 2: Hand count difference! Before: 170 After: 173
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 510 After: 511
ERROR 2: Hand count difference! Before: 188 After: 219
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 617 After: 618
ERROR 2: Hand count difference! Before: 362 After: 377
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 663 After: 664
ERROR 2: Hand count difference! Before: 426 After: 427
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 531 After: 532
ERROR 2: Hand count difference! Before: 4 After: 17
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 507 After: 508
ERROR 2: Hand count difference! Before: 198 After: 261
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 405 After: 406
ERROR 2: Hand count difference! Before: 150 After: 203
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 384 After: 385
ERROR 2: Hand count difference! Before: 216 After: 219
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 727 After: 728
ERROR 2: Hand count difference! Before: 259 After: 258
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 757 After: 758
ERROR 2: Hand count difference! Before: 282 After: 285
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 146 After: 147
ERROR 2: Hand count difference! Before: 197 After: 198
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 475 After: 476
ERROR 2: Hand count difference! Before: 93 After: 98
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 830 After: 831
ERROR 2: Hand count difference! Before: 424 After: 437
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 372 After: 373
ERROR 2: Hand count difference! Before: 500 After: 523
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 933 After: 934
ERROR 2: Hand count difference! Before: 436 After: 473
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 545 After: 546
ERROR 2: Hand count difference! Before: 265 After: 264
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 741 After: 742
ERROR 2: Hand count difference! Before: 297 After: 322
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 437 After: 438
ERROR 2: Hand count difference! Before: 54 After: 75
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 491 After: 492
ERROR 2: Hand count difference! Before: 96 After: 97
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 652 After: 653
ERROR 2: Hand count difference! Before: 292 After: 323
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 288 After: 289
ERROR 2: Hand count difference! Before: 96 After: 107
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 527 After: 528
ERROR 2: Hand count difference! Before: 187 After: 188
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 332 After: 333
ERROR 2: Hand count difference! Before: 48 After: 49
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 812 After: 813
ERROR 2: Hand count difference! Before: 215 After: 242
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 271 After: 272
ERROR 2: Hand count difference! Before: 186 After: 247
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 412 After: 413
ERROR 2: Hand count difference! Before: 38 After: 53
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 437 After: 438
ERROR 2: Hand count difference! Before: 317 After: 316
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 783 After: 784
ERROR 2: Hand count difference! Before: 357 After: 372
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 382 After: 383
ERROR 2: Hand count difference! Before: 62 After: 103
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 600 After: 601
ERROR 2: Hand count difference! Before: 217 After: 220
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 440 After: 441
ERROR 2: Hand count difference! Before: 318 After: 329
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 450 After: 451
ERROR 2: Hand count difference! Before: 292 After: 293
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 851 After: 852
ERROR 2: Hand count difference! Before: 444 After: 447
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 308 After: 309
ERROR 2: Hand count difference! Before: 456 After: 513
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 180 After: 181
ERROR 2: Hand count difference! Before: 362 After: 363
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 894 After: 895
ERROR 2: Hand count difference! Before: 475 After: 474
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 921 After: 922
ERROR 2: Hand count difference! Before: 96 After: 99
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 689 After: 690
ERROR 2: Hand count difference! Before: 333 After: 332
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 672 After: 673
ERROR 2: Hand count difference! Before: 64 After: 79
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 180 After: 181
ERROR 2: Hand count difference! Before: 460 After: 499
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 574 After: 575
ERROR 2: Hand count difference! Before: 154 After: 185
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 799 After: 800
ERROR 2: Hand count difference! Before: 290 After: 291
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 514 After: 515
ERROR 2: Hand count difference! Before: 233 After: 306
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 606 After: 607
ERROR 2: Hand count difference! Before: 447 After: 462
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 662 After: 663
ERROR 2: Hand count difference! Before: 169 After: 172
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 740 After: 741
ERROR 2: Hand count difference! Before: 251 After: 262
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 746 After: 747
ERROR 2: Hand count difference! Before: 69 After: 94
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 555 After: 556
ERROR 2: Hand count difference! Before: 438 After: 437
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 318 After: 319
ERROR 2: Hand count difference! Before: 305 After: 338
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 410 After: 411
ERROR 2: Hand count difference! Before: 343 After: 356
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 518 After: 519
ERROR 2: Hand count difference! Before: 308 After: 317
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 373 After: 374
ERROR 2: Hand count difference! Before: 234 After: 239
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 718 After: 719
ERROR 2: Hand count difference! Before: 60 After: 119
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 139 After: 140
ERROR 2: Hand count difference! Before: 63 After: 110
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 254 After: 255
ERROR 2: Hand count difference! Before: 320 After: 319
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 259 After: 260
ERROR 2: Hand count difference! Before: 285 After: 304
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 637 After: 638
ERROR 2: Hand count difference! Before: 376 After: 375
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 335 After: 336
ERROR 2: Hand count difference! Before: 315 After: 334
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 631 After: 632
ERROR 2: Hand count difference! Before: 328 After: 337
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 548 After: 549
ERROR 2: Hand count difference! Before: 228 After: 249
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 428 After: 429
ERROR 2: Hand count difference! Before: 6 After: 15
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 541 After: 542
ERROR 2: Hand count difference! Before: 22 After: 29
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 373 After: 374
ERROR 2: Hand count difference! Before: 362 After: 395
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 387 After: 388
ERROR 2: Hand count difference! Before: 381 After: 402
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 317 After: 318
ERROR 2: Hand count difference! Before: 467 After: 470
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 490 After: 491
ERROR 2: Hand count difference! Before: 383 After: 394
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 498 After: 499
ERROR 2: Hand count difference! Before: 292 After: 309
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 455 After: 456
ERROR 2: Hand count difference! Before: 127 After: 150
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 444 After: 445
ERROR 2: Hand count difference! Before: 190 After: 207
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 533 After: 534
ERROR 2: Hand count difference! Before: 131 After: 130
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 303 After: 304
ERROR 2: Hand count difference! Before: 397 After: 418
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 655 After: 656
ERROR 2: Hand count difference! Before: 329 After: 332
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 459 After: 460
ERROR 2: Hand count difference! Before: 174 After: 203
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 82 After: 83
ERROR 2: Hand count difference! Before: 81 After: 92
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 792 After: 793
ERROR 2: Hand count difference! Before: 26 After: 41
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 486 After: 487
ERROR 2: Hand count difference! Before: 468 After: 481
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 504 After: 505
ERROR 2: Hand count difference! Before: 162 After: 169
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 510 After: 511
ERROR 2: Hand count difference! Before: 252 After: 255
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 358 After: 359
ERROR 2: Hand count difference! Before: 53 After: 58
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 606 After: 607
ERROR 2: Hand count difference! Before: 147 After: 150
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 552 After: 553
ERROR 2: Hand count difference! Before: 134 After: 145
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 380 After: 381
ERROR 2: Hand count difference! Before: 160 After: 197
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 883 After: 884
ERROR 2: Hand count difference! Before: 145 After: 148
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 589 After: 590
ERROR 2: Hand count difference! Before: 38 After: 73
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 702 After: 703
ERROR 2: Hand count difference! Before: 476 After: 477
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 399 After: 400
ERROR 2: Hand count difference! Before: 232 After: 233
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 928 After: 929
ERROR 2: Hand count difference! Before: 300 After: 303
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 546 After: 547
ERROR 2: Hand count difference! Before: 176 After: 221
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 425 After: 426
ERROR 2: Hand count difference! Before: 427 After: 430
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 719 After: 720
ERROR 2: Hand count difference! Before: 305 After: 328
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 88 After: 89
ERROR 2: Hand count difference! Before: 491 After: 494
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 811 After: 812
ERROR 2: Hand count difference! Before: 289 After: 300
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 125 After: 126
ERROR 2: Hand count difference! Before: 344 After: 365
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 536 After: 537
ERROR 2: Hand count difference! Before: 128 After: 153
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 518 After: 519
ERROR 2: Hand count difference! Before: 224 After: 243
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 449 After: 450
ERROR 2: Hand count difference! Before: 443 After: 482
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 612 After: 613
ERROR 2: Hand count difference! Before: 421 After: 438
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 545 After: 546
ERROR 2: Hand count difference! Before: 338 After: 343
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 821 After: 822
ERROR 2: Hand count difference! Before: 393 After: 400
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 909 After: 910
ERROR 2: Hand count difference! Before: 96 After: 107
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 551 After: 552
ERROR 2: Hand count difference! Before: 431 After: 442
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 442 After: 443
ERROR 2: Hand count difference! Before: 6 After: 21
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 685 After: 686
ERROR 2: Hand count difference! Before: 346 After: 355
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 596 After: 597
ERROR 2: Hand count difference! Before: 42 After: 71
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 326 After: 327
ERROR 2: Hand count difference! Before: 261 After: 270
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 794 After: 795
ERROR 2: Hand count difference! Before: 381 After: 382
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 467 After: 468
ERROR 2: Hand count difference! Before: 242 After: 243
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 391 After: 392
ERROR 2: Hand count difference! Before: 167 After: 176
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 875 After: 876
ERROR 2: Hand count difference! Before: 260 After: 285
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 201 After: 202
ERROR 2: Hand count difference! Before: 68 After: 73
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 889 After: 890
ERROR 2: Hand count difference! Before: 416 After: 435
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 365 After: 366
ERROR 2: Hand count difference! Before: 393 After: 410
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 610 After: 611
ERROR 2: Hand count difference! Before: 329 After: 332
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 580 After: 581
ERROR 2: Hand count difference! Before: 138 After: 137
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 520 After: 521
ERROR 2: Hand count difference! Before: 417 After: 424
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 471 After: 472
ERROR 2: Hand count difference! Before: 348 After: 459
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 485 After: 486
ERROR 2: Hand count difference! Before: 376 After: 409
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 598 After: 599
ERROR 2: Hand count difference! Before: 367 After: 394
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 578 After: 579
ERROR 2: Hand count difference! Before: 14 After: 15
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 409 After: 410
ERROR 2: Hand count difference! Before: 244 After: 253
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 260 After: 261
ERROR 2: Hand count difference! Before: 300 After: 311
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 497 After: 498
ERROR 2: Hand count difference! Before: 47 After: 92
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 489 After: 490
ERROR 2: Hand count difference! Before: 58 After: 73
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 261 After: 262
ERROR 2: Hand count difference! Before: 35 After: 46
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 399 After: 400
ERROR 2: Hand count difference! Before: 487 After: 516
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 991 After: 992
ERROR 2: Hand count difference! Before: 427 After: 428
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 629 After: 630
ERROR 2: Hand count difference! Before: 156 After: 167
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 797 After: 798
ERROR 2: Hand count difference! Before: 62 After: 65
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 300 After: 301
ERROR 2: Hand count difference! Before: 349 After: 356
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 186 After: 187
ERROR 2: Hand count difference! Before: 71 After: 90
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 320 After: 321
ERROR 2: Hand count difference! Before: 230 After: 239
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 865 After: 866
ERROR 2: Hand count difference! Before: 44 After: 47
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 400 After: 401
ERROR 2: Hand count difference! Before: 43 After: 48
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 360 After: 361
ERROR 2: Hand count difference! Before: 284 After: 283
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 553 After: 554
ERROR 2: Hand count difference! Before: 131 After: 132
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 861 After: 862
ERROR 2: Hand count difference! Before: 46 After: 55
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 848 After: 849
ERROR 2: Hand count difference! Before: 111 After: 112
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 206 After: 207
ERROR 2: Hand count difference! Before: 41 After: 40
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 367 After: 368
ERROR 2: Hand count difference! Before: 60 After: 169
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 780 After: 781
ERROR 2: Hand count difference! Before: 138 After: 149
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 307 After: 308
ERROR 2: Hand count difference! Before: 392 After: 403
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 501 After: 502
ERROR 2: Hand count difference! Before: 181 After: 186
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 757 After: 758
ERROR 2: Hand count difference! Before: 327 After: 346
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 380 After: 381
ERROR 2: Hand count difference! Before: 44 After: 105
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 623 After: 624
ERROR 2: Hand count difference! Before: 175 After: 180
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 326 After: 327
ERROR 2: Hand count difference! Before: 102 After: 113
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 451 After: 452
ERROR 2: Hand count difference! Before: 445 After: 448
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 306 After: 307
ERROR 2: Hand count difference! Before: 190 After: 197
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 479 After: 480
ERROR 2: Hand count difference! Before: 387 After: 402
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 425 After: 426
ERROR 2: Hand count difference! Before: 469 After: 494
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 837 After: 838
ERROR 2: Hand count difference! Before: 335 After: 344
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 262 After: 263
ERROR 2: Hand count difference! Before: 172 After: 203
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 407 After: 408
ERROR 2: Hand count difference! Before: 192 After: 201
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 565 After: 566
ERROR 2: Hand count difference! Before: 171 After: 190
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 690 After: 691
ERROR 2: Hand count difference! Before: 484 After: 487
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 155 After: 156
ERROR 2: Hand count difference! Before: 397 After: 396
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 650 After: 651
ERROR 2: Hand count difference! Before: 157 After: 156
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 488 After: 489
ERROR 2: Hand count difference! Before: 15 After: 18
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 621 After: 622
ERROR 2: Hand count difference! Before: 117 After: 116
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 505 After: 506
ERROR 2: Hand count difference! Before: 279 After: 280
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 605 After: 606
ERROR 2: Hand count difference! Before: 212 After: 215
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 376 After: 377
ERROR 2: Hand count difference! Before: 327 After: 326
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 928 After: 929
ERROR 2: Hand count difference! Before: 203 After: 208
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 593 After: 594
ERROR 2: Hand count difference! Before: 53 After: 54
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 653 After: 654
ERROR 2: Hand count difference! Before: 246 After: 253
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 300 After: 301
ERROR 2: Hand count difference! Before: 188 After: 191
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 406 After: 407
ERROR 2: Hand count difference! Before: 391 After: 408
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 700 After: 701
ERROR 2: Hand count difference! Before: 80 After: 155
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 598 After: 599
ERROR 2: Hand count difference! Before: 206 After: 205
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 440 After: 441
ERROR 2: Hand count difference! Before: 60 After: 107
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 365 After: 366
ERROR 2: Hand count difference! Before: 163 After: 170
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 485 After: 486
ERROR 2: Hand count difference! Before: 216 After: 223
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 592 After: 593
ERROR 2: Hand count difference! Before: 487 After: 520
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 709 After: 710
ERROR 2: Hand count difference! Before: 252 After: 255
ERROR 1: Total card count difference! Should be 2 less than before total. Before: 807 After: 808
ERROR 2: Hand count difference! Before: 26 After: 57
Play Adventurer Tests are concluded.

----------------- Testing Card: Village ----------------
ERROR 1: Hand count difference! Before: 191 After: 192
ERROR 1: Hand count difference! Before: 486 After: 487
ERROR 1: Hand count difference! Before: 119 After: 120
ERROR 1: Hand count difference! Before: 35 After: 36
ERROR 1: Hand count difference! Before: 254 After: 255
ERROR 1: Hand count difference! Before: 316 After: 317
ERROR 1: Hand count difference! Before: 306 After: 307
ERROR 1: Hand count difference! Before: 101 After: 102
ERROR 1: Hand count difference! Before: 142 After: 143
ERROR 1: Hand count difference! Before: 406 After: 407
ERROR 1: Hand count difference! Before: 317 After: 318
ERROR 1: Hand count difference! Before: 73 After: 74
ERROR 1: Hand count difference! Before: 199 After: 200
ERROR 1: Hand count difference! Before: 364 After: 365
ERROR 1: Hand count difference! Before: 24 After: 25
ERROR 1: Hand count difference! Before: 97 After: 98
ERROR 1: Hand count difference! Before: 363 After: 364
ERROR 1: Hand count difference! Before: 129 After: 130
ERROR 1: Hand count difference! Before: 493 After: 494
ERROR 1: Hand count difference! Before: 431 After: 432
ERROR 1: Hand count difference! Before: 183 After: 184
ERROR 1: Hand count difference! Before: 443 After: 444
ERROR 1: Hand count difference! Before: 172 After: 173
ERROR 1: Hand count difference! Before: 159 After: 160
ERROR 1: Hand count difference! Before: 439 After: 440
ERROR 1: Hand count difference! Before: 461 After: 462
ERROR 1: Hand count difference! Before: 17 After: 18
ERROR 1: Hand count difference! Before: 292 After: 293
ERROR 1: Hand count difference! Before: 328 After: 329
ERROR 1: Hand count difference! Before: 244 After: 245
ERROR 1: Hand count difference! Before: 490 After: 491
ERROR 1: Hand count difference! Before: 482 After: 483
ERROR 1: Hand count difference! Before: 367 After: 368
ERROR 1: Hand count difference! Before: 206 After: 207
ERROR 1: Hand count difference! Before: 499 After: 500
ERROR 1: Hand count difference! Before: 266 After: 267
ERROR 1: Hand count difference! Before: 176 After: 177
ERROR 1: Hand count difference! Before: 456 After: 457
ERROR 1: Hand count difference! Before: 139 After: 140
ERROR 1: Hand count difference! Before: 46 After: 47
ERROR 1: Hand count difference! Before: 214 After: 215
ERROR 1: Hand count difference! Before: 223 After: 224
ERROR 1: Hand count difference! Before: 464 After: 465
ERROR 1: Hand count difference! Before: 71 After: 72
ERROR 1: Hand count difference! Before: 364 After: 365
ERROR 1: Hand count difference! Before: 357 After: 358
ERROR 1: Hand count difference! Before: 336 After: 337
ERROR 1: Hand count difference! Before: 168 After: 169
ERROR 1: Hand count difference! Before: 377 After: 378
ERROR 1: Hand count difference! Before: 300 After: 301
ERROR 1: Hand count difference! Before: 186 After: 187
ERROR 1: Hand count difference! Before: 63 After: 64
ERROR 1: Hand count difference! Before: 317 After: 318
ERROR 1: Hand count difference! Before: 168 After: 169
ERROR 1: Hand count difference! Before: 367 After: 368
ERROR 1: Hand count difference! Before: 280 After: 281
ERROR 1: Hand count difference! Before: 228 After: 229
ERROR 1: Hand count difference! Before: 273 After: 274
ERROR 1: Hand count difference! Before: 198 After: 199
ERROR 1: Hand count difference! Before: 21 After: 22
ERROR 1: Hand count difference! Before: 80 After: 81
ERROR 1: Hand count difference! Before: 469 After: 470
ERROR 1: Hand count difference! Before: 2 After: 3
ERROR 1: Hand count difference! Before: 138 After: 139
ERROR 1: Hand count difference! Before: 385 After: 386
ERROR 1: Hand count difference! Before: 322 After: 323
ERROR 1: Hand count difference! Before: 395 After: 396
ERROR 1: Hand count difference! Before: 497 After: 498
ERROR 1: Hand count difference! Before: 61 After: 62
ERROR 1: Hand count difference! Before: 383 After: 384
ERROR 1: Hand count difference! Before: 284 After: 285
ERROR 1: Hand count difference! Before: 434 After: 435
ERROR 1: Hand count difference! Before: 480 After: 481
ERROR 1: Hand count difference! Before: 26 After: 27
ERROR 1: Hand count difference! Before: 269 After: 270
ERROR 1: Hand count difference! Before: 282 After: 283
ERROR 1: Hand count difference! Before: 285 After: 286
ERROR 1: Hand count difference! Before: 80 After: 81
ERROR 1: Hand count difference! Before: 84 After: 85
ERROR 1: Hand count difference! Before: 173 After: 174
ERROR 1: Hand count difference! Before: 436 After: 437
ERROR 1: Hand count difference! Before: 139 After: 140
ERROR 1: Hand count difference! Before: 494 After: 495
ERROR 1: Hand count difference! Before: 414 After: 415
ERROR 1: Hand count difference! Before: 351 After: 352
ERROR 1: Hand count difference! Before: 370 After: 371
ERROR 1: Hand count difference! Before: 133 After: 134
ERROR 1: Hand count difference! Before: 340 After: 341
ERROR 1: Hand count difference! Before: 16 After: 17
ERROR 1: Hand count difference! Before: 187 After: 188
ERROR 1: Hand count difference! Before: 167 After: 168
ERROR 1: Hand count difference! Before: 167 After: 168
ERROR 1: Hand count difference! Before: 359 After: 360
ERROR 1: Hand count difference! Before: 164 After: 165
ERROR 1: Hand count difference! Before: 405 After: 406
ERROR 1: Hand count difference! Before: 337 After: 338
ERROR 1: Hand count difference! Before: 187 After: 188
ERROR 1: Hand count difference! Before: 40 After: 41
ERROR 1: Hand count difference! Before: 268 After: 269
ERROR 1: Hand count difference! Before: 442 After: 443
ERROR 1: Hand count difference! Before: 430 After: 431
ERROR 1: Hand count difference! Before: 353 After: 354
ERROR 1: Hand count difference! Before: 378 After: 379
ERROR 1: Hand count difference! Before: 143 After: 144
ERROR 1: Hand count difference! Before: 366 After: 367
ERROR 1: Hand count difference! Before: 115 After: 116
ERROR 1: Hand count difference! Before: 85 After: 86
ERROR 1: Hand count difference! Before: 356 After: 357
ERROR 1: Hand count difference! Before: 91 After: 92
ERROR 1: Hand count difference! Before: 375 After: 376
ERROR 1: Hand count difference! Before: 37 After: 38
ERROR 1: Hand count difference! Before: 381 After: 382
ERROR 1: Hand count difference! Before: 209 After: 210
ERROR 1: Hand count difference! Before: 408 After: 409
ERROR 1: Hand count difference! Before: 123 After: 124
ERROR 1: Hand count difference! Before: 84 After: 85
ERROR 1: Hand count difference! Before: 411 After: 412
ERROR 1: Hand count difference! Before: 117 After: 118
ERROR 1: Hand count difference! Before: 484 After: 485
ERROR 1: Hand count difference! Before: 19 After: 20
ERROR 1: Hand count difference! Before: 360 After: 361
ERROR 1: Hand count difference! Before: 37 After: 38
ERROR 1: Hand count difference! Before: 83 After: 84
ERROR 1: Hand count difference! Before: 212 After: 213
ERROR 1: Hand count difference! Before: 283 After: 284
ERROR 1: Hand count difference! Before: 463 After: 464
ERROR 1: Hand count difference! Before: 123 After: 124
ERROR 1: Hand count difference! Before: 443 After: 444
ERROR 1: Hand count difference! Before: 185 After: 186
ERROR 1: Hand count difference! Before: 99 After: 100
ERROR 1: Hand count difference! Before: 470 After: 471
ERROR 1: Hand count difference! Before: 224 After: 225
ERROR 1: Hand count difference! Before: 298 After: 299
ERROR 1: Hand count difference! Before: 461 After: 462
ERROR 1: Hand count difference! Before: 71 After: 72
ERROR 1: Hand count difference! Before: 482 After: 483
ERROR 1: Hand count difference! Before: 8 After: 9
ERROR 1: Hand count difference! Before: 322 After: 323
ERROR 1: Hand count difference! Before: 496 After: 497
ERROR 1: Hand count difference! Before: 455 After: 456
ERROR 1: Hand count difference! Before: 326 After: 327
ERROR 1: Hand count difference! Before: 285 After: 286
ERROR 1: Hand count difference! Before: 280 After: 281
ERROR 1: Hand count difference! Before: 375 After: 376
ERROR 1: Hand count difference! Before: 153 After: 154
ERROR 1: Hand count difference! Before: 196 After: 197
ERROR 1: Hand count difference! Before: 83 After: 84
ERROR 1: Hand count difference! Before: 242 After: 243
ERROR 1: Hand count difference! Before: 349 After: 350
ERROR 1: Hand count difference! Before: 339 After: 340
ERROR 1: Hand count difference! Before: 27 After: 28
ERROR 1: Hand count difference! Before: 6 After: 7
ERROR 1: Hand count difference! Before: 180 After: 181
ERROR 1: Hand count difference! Before: 464 After: 465
ERROR 1: Hand count difference! Before: 253 After: 254
ERROR 1: Hand count difference! Before: 480 After: 481
ERROR 1: Hand count difference! Before: 25 After: 26
ERROR 1: Hand count difference! Before: 331 After: 332
ERROR 1: Hand count difference! Before: 65 After: 66
ERROR 1: Hand count difference! Before: 156 After: 157
ERROR 1: Hand count difference! Before: 313 After: 314
ERROR 1: Hand count difference! Before: 316 After: 317
ERROR 1: Hand count difference! Before: 32 After: 33
ERROR 1: Hand count difference! Before: 292 After: 293
ERROR 1: Hand count difference! Before: 98 After: 99
ERROR 1: Hand count difference! Before: 76 After: 77
ERROR 1: Hand count difference! Before: 425 After: 426
ERROR 1: Hand count difference! Before: 423 After: 424
ERROR 1: Hand count difference! Before: 250 After: 251
ERROR 1: Hand count difference! Before: 141 After: 142
ERROR 1: Hand count difference! Before: 32 After: 33
ERROR 1: Hand count difference! Before: 496 After: 497
ERROR 1: Hand count difference! Before: 453 After: 454
ERROR 1: Hand count difference! Before: 354 After: 355
ERROR 1: Hand count difference! Before: 318 After: 319
ERROR 1: Hand count difference! Before: 104 After: 105
ERROR 1: Hand count difference! Before: 369 After: 370
ERROR 1: Hand count difference! Before: 449 After: 450
ERROR 1: Hand count difference! Before: 447 After: 448
ERROR 1: Hand count difference! Before: 40 After: 41
ERROR 1: Hand count difference! Before: 442 After: 443
ERROR 1: Hand count difference! Before: 282 After: 283
ERROR 1: Hand count difference! Before: 258 After: 259
ERROR 1: Hand count difference! Before: 277 After: 278
ERROR 1: Hand count difference! Before: 295 After: 296
ERROR 1: Hand count difference! Before: 134 After: 135
ERROR 1: Hand count difference! Before: 353 After: 354
ERROR 1: Hand count difference! Before: 245 After: 246
ERROR 1: Hand count difference! Before: 288 After: 289
ERROR 1: Hand count difference! Before: 424 After: 425
ERROR 1: Hand count difference! Before: 379 After: 380
ERROR 1: Hand count difference! Before: 497 After: 498
ERROR 1: Hand count difference! Before: 34 After: 35
ERROR 1: Hand count difference! Before: 406 After: 407
ERROR 1: Hand count difference! Before: 483 After: 484
ERROR 1: Hand count difference! Before: 212 After: 213
ERROR 1: Hand count difference! Before: 144 After: 145
ERROR 1: Hand count difference! Before: 123 After: 124
ERROR 1: Hand count difference! Before: 40 After: 41
ERROR 1: Hand count difference! Before: 245 After: 246
ERROR 1: Hand count difference! Before: 174 After: 175
ERROR 1: Hand count difference! Before: 329 After: 330
ERROR 1: Hand count difference! Before: 175 After: 176
ERROR 1: Hand count difference! Before: 420 After: 421
ERROR 1: Hand count difference! Before: 60 After: 61
ERROR 1: Hand count difference! Before: 476 After: 477
ERROR 1: Hand count difference! Before: 15 After: 16
ERROR 1: Hand count difference! Before: 104 After: 105
ERROR 1: Hand count difference! Before: 228 After: 229
ERROR 1: Hand count difference! Before: 280 After: 281
ERROR 1: Hand count difference! Before: 258 After: 259
ERROR 1: Hand count difference! Before: 58 After: 59
ERROR 1: Hand count difference! Before: 282 After: 283
ERROR 1: Hand count difference! Before: 375 After: 376
ERROR 1: Hand count difference! Before: 201 After: 202
ERROR 1: Hand count difference! Before: 23 After: 24
ERROR 1: Hand count difference! Before: 94 After: 95
ERROR 1: Hand count difference! Before: 380 After: 381
ERROR 1: Hand count difference! Before: 319 After: 320
ERROR 1: Hand count difference! Before: 338 After: 339
ERROR 1: Hand count difference! Before: 277 After: 278
ERROR 1: Hand count difference! Before: 145 After: 146
ERROR 1: Hand count difference! Before: 499 After: 500
ERROR 1: Hand count difference! Before: 496 After: 497
ERROR 1: Hand count difference! Before: 397 After: 398
ERROR 1: Hand count difference! Before: 427 After: 428
ERROR 1: Hand count difference! Before: 230 After: 231
ERROR 1: Hand count difference! Before: 460 After: 461
ERROR 1: Hand count difference! Before: 66 After: 67
ERROR 1: Hand count difference! Before: 115 After: 116
ERROR 1: Hand count difference! Before: 9 After: 10
ERROR 1: Hand count difference! Before: 480 After: 481
ERROR 1: Hand count difference! Before: 168 After: 169
ERROR 1: Hand count difference! Before: 485 After: 486
ERROR 1: Hand count difference! Before: 143 After: 144
ERROR 1: Hand count difference! Before: 129 After: 130
ERROR 1: Hand count difference! Before: 66 After: 67
ERROR 1: Hand count difference! Before: 273 After: 274
ERROR 1: Hand count difference! Before: 90 After: 91
ERROR 1: Hand count difference! Before: 268 After: 269
ERROR 1: Hand count difference! Before: 187 After: 188
ERROR 1: Hand count difference! Before: 253 After: 254
ERROR 1: Hand count difference! Before: 151 After: 152
ERROR 1: Hand count difference! Before: 109 After: 110
ERROR 1: Hand count difference! Before: 181 After: 182
ERROR 1: Hand count difference! Before: 277 After: 278
ERROR 1: Hand count difference! Before: 248 After: 249
ERROR 1: Hand count difference! Before: 196 After: 197
ERROR 1: Hand count difference! Before: 366 After: 367
ERROR 1: Hand count difference! Before: 357 After: 358
Play Village testing concluded.

----------------- Testing Card: Council_Room ----------------
Play Council_Room testing has concluded.

File 'dominion.c'
Lines executed:35.13% of 575
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:// Assignment 2, CS362-400-W16
        -:    2:// Andrew M. Calhoun
        -:    3:// calhouna@oregonstate.edu
        -:    4:// Due Date: 1/17/2016
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12:
        -:   13:
        -:   14:
    57910:   15:int compare(const void* a, const void* b) {
    57910:   16:  if (*(int*)a > *(int*)b)
    28735:   17:    return 1;
    29175:   18:  if (*(int*)a < *(int*)b)
    14977:   19:    return -1;
    14198:   20:  return 0;
        -:   21:}
        -:   22:
    #####:   23:struct gameState* newGame() {
    #####:   24:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   25:  return g;
        -:   26:}
        -:   27:
    #####:   28:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   29:		  int k8, int k9, int k10) {
    #####:   30:  int* k = malloc(10 * sizeof(int));
    #####:   31:  k[0] = k1;
    #####:   32:  k[1] = k2;
    #####:   33:  k[2] = k3;
    #####:   34:  k[3] = k4;
    #####:   35:  k[4] = k5;
    #####:   36:  k[5] = k6;
    #####:   37:  k[6] = k7;
    #####:   38:  k[7] = k8;
    #####:   39:  k[8] = k9;
    #####:   40:  k[9] = k10;
    #####:   41:  return k;
        -:   42:}
        -:   43:
       29:   44:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   45:		   struct gameState *state) {
        -:   46:
        -:   47:  int i;
        -:   48:  int j;
        -:   49:  int it;
        -:   50:  //set up random number generator
       29:   51:  SelectStream(1);
       29:   52:  PutSeed((long)randomSeed);
        -:   53:
        -:   54:  //check number of players
       29:   55:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   56:    {
    #####:   57:      return -1;
        -:   58:    }
        -:   59:
        -:   60:  //set number of players
       29:   61:  state->numPlayers = numPlayers;
        -:   62:
        -:   63:  //check selected kingdom cards are different
      319:   64:  for (i = 0; i < 10; i++)
        -:   65:    {
     3190:   66:      for (j = 0; j < 10; j++)
        -:   67:        {
     2900:   68:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   69:	    {
    #####:   70:	      return -1;
        -:   71:	    }
        -:   72:        }
        -:   73:    }
        -:   74:
        -:   75:
        -:   76:  //initialize supply
        -:   77:  ///////////////////////////////
        -:   78:
        -:   79:  //set number of Curse cards
       29:   80:  if (numPlayers == 2)
        -:   81:    {
       27:   82:      state->supplyCount[curse] = 10;
        -:   83:    }
        2:   84:  else if (numPlayers == 3)
        -:   85:    {
        2:   86:      state->supplyCount[curse] = 20;
        -:   87:    }
        -:   88:  else
        -:   89:    {
    #####:   90:      state->supplyCount[curse] = 30;
        -:   91:    }
        -:   92:
        -:   93:  //set number of Victory cards
       29:   94:  if (numPlayers == 2)
        -:   95:    {
       27:   96:      state->supplyCount[estate] = 8;
       27:   97:      state->supplyCount[duchy] = 8;
       27:   98:      state->supplyCount[province] = 8;
        -:   99:    }
        -:  100:  else
        -:  101:    {
        2:  102:      state->supplyCount[estate] = 12;
        2:  103:      state->supplyCount[duchy] = 12;
        2:  104:      state->supplyCount[province] = 12;
        -:  105:    }
        -:  106:
        -:  107:  //set number of Treasure cards
       29:  108:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       29:  109:  state->supplyCount[silver] = 40;
       29:  110:  state->supplyCount[gold] = 30;
        -:  111:
        -:  112:  //set number of Kingdom cards
      609:  113:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  114:    {
     4785:  115:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  116:	{
     4495:  117:	  if (kingdomCards[j] == i)
        -:  118:	    {
        -:  119:	      //check if card is a 'Victory' Kingdom card
      345:  120:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  121:		{
       55:  122:		  if (numPlayers == 2){
       52:  123:		    state->supplyCount[i] = 8;
        -:  124:		  }
        3:  125:		  else{ state->supplyCount[i] = 12; }
        -:  126:		}
        -:  127:	      else
        -:  128:		{
      235:  129:		  state->supplyCount[i] = 10;
        -:  130:		}
      290:  131:	      break;
        -:  132:	    }
        -:  133:	  else    //card is not in the set choosen for the game
        -:  134:	    {
     4205:  135:	      state->supplyCount[i] = -1;
        -:  136:	    }
        -:  137:	}
        -:  138:
        -:  139:    }
        -:  140:
        -:  141:  ////////////////////////
        -:  142:  //supply initialization complete
        -:  143:
        -:  144:  //set player decks
       89:  145:  for (i = 0; i < numPlayers; i++)
        -:  146:    {
       60:  147:      state->deckCount[i] = 0;
      240:  148:      for (j = 0; j < 3; j++)
        -:  149:	{
      180:  150:	  state->deck[i][j] = estate;
      180:  151:	  state->deckCount[i]++;
        -:  152:	}
      480:  153:      for (j = 3; j < 10; j++)
        -:  154:	{
      420:  155:	  state->deck[i][j] = copper;
      420:  156:	  state->deckCount[i]++;
        -:  157:	}
        -:  158:    }
        -:  159:
        -:  160:  //shuffle player decks
       89:  161:  for (i = 0; i < numPlayers; i++)
        -:  162:    {
       60:  163:      if ( shuffle(i, state) < 0 )
        -:  164:	{
    #####:  165:	  return -1;
        -:  166:	}
        -:  167:    }
        -:  168:
        -:  169:  //draw player hands
       89:  170:  for (i = 0; i < numPlayers; i++)
        -:  171:    {
        -:  172:      //initialize hand size to zero
       60:  173:      state->handCount[i] = 0;
       60:  174:      state->discardCount[i] = 0;
        -:  175:      //draw 5 cards
        -:  176:      // for (j = 0; j < 5; j++)
        -:  177:      //	{
        -:  178:      //	  drawCard(i, state);
        -:  179:      //	}
        -:  180:    }
        -:  181:
        -:  182:  //set embargo tokens to 0 for all supply piles
      812:  183:  for (i = 0; i <= treasure_map; i++)
        -:  184:    {
      783:  185:      state->embargoTokens[i] = 0;
        -:  186:    }
        -:  187:
        -:  188:  //initialize first player's turn
       29:  189:  state->outpostPlayed = 0;
       29:  190:  state->phase = 0;
       29:  191:  state->numActions = 1;
       29:  192:  state->numBuys = 1;
       29:  193:  state->playedCardCount = 0;
       29:  194:  state->whoseTurn = 0;
       29:  195:  state->handCount[state->whoseTurn] = 0;
        -:  196:  //int it; move to top
        -:  197:
        -:  198:  //Moved draw cards to here, only drawing at the start of a turn
      174:  199:  for (it = 0; it < 5; it++){
      145:  200:    drawCard(state->whoseTurn, state);
        -:  201:  }
        -:  202:
       29:  203:  updateCoins(state->whoseTurn, state, 0);
        -:  204:
       29:  205:  return 0;
        -:  206:}
        -:  207:
      163:  208:int shuffle(int player, struct gameState *state) {
        -:  209:
        -:  210:
        -:  211:  int newDeck[MAX_DECK];
      163:  212:  int newDeckPos = 0;
        -:  213:  int card;
        -:  214:  int i;
        -:  215:
      163:  216:  if (state->deckCount[player] < 1)
        6:  217:    return -1;
      157:  218:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  219:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  220:
    10622:  221:  while (state->deckCount[player] > 0) {
    10308:  222:    card = floor(Random() * state->deckCount[player]);
    10308:  223:    newDeck[newDeckPos] = state->deck[player][card];
    10308:  224:    newDeckPos++;
   421685:  225:    for (i = card; i < state->deckCount[player]-1; i++) {
   411377:  226:      state->deck[player][i] = state->deck[player][i+1];
        -:  227:    }
    10308:  228:    state->deckCount[player]--;
        -:  229:  }
    10465:  230:  for (i = 0; i < newDeckPos; i++) {
    10308:  231:    state->deck[player][i] = newDeck[i];
    10308:  232:    state->deckCount[player]++;
        -:  233:  }
        -:  234:
      157:  235:  return 0;
        -:  236:}
        -:  237:
    #####:  238:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  239:{
        -:  240:  int card;
    #####:  241:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  242:
        -:  243:  //check if it is the right phase
    #####:  244:  if (state->phase != 0)
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:
        -:  249:  //check if player has enough actions
    #####:  250:  if ( state->numActions < 1 )
        -:  251:    {
    #####:  252:      return -1;
        -:  253:    }
        -:  254:
        -:  255:  //get card played
    #####:  256:  card = handCard(handPos, state);
        -:  257:
        -:  258:  //check if selected card is an action
    #####:  259:  if ( card < adventurer || card > treasure_map )
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:
        -:  264:  //play card
    #####:  265:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  266:    {
    #####:  267:      return -1;
        -:  268:    }
        -:  269:
        -:  270:  //reduce number of actions
    #####:  271:  state->numActions--;
        -:  272:
        -:  273:  //update coins (Treasure cards may be added with card draws)
    #####:  274:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  275:
    #####:  276:  return 0;
        -:  277:}
        -:  278:
    #####:  279:int buyCard(int supplyPos, struct gameState *state) {
        -:  280:  int who;
    #####:  281:  if (DEBUG){
        -:  282:    printf("Entering buyCard...\n");
        -:  283:  }
        -:  284:
        -:  285:  // I don't know what to do about the phase thing.
        -:  286:
    #####:  287:  who = state->whoseTurn;
        -:  288:
    #####:  289:  if (state->numBuys < 1){
    #####:  290:    if (DEBUG)
        -:  291:      printf("You do not have any buys left\n");
    #####:  292:    return -1;
    #####:  293:  } else if (supplyCount(supplyPos, state) <1){
    #####:  294:    if (DEBUG)
        -:  295:      printf("There are not any of that type of card left\n");
    #####:  296:    return -1;
    #####:  297:  } else if (state->coins < getCost(supplyPos)){
    #####:  298:    if (DEBUG)
        -:  299:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:    return -1;
        -:  301:  } else {
    #####:  302:    state->phase=1;
        -:  303:    //state->supplyCount[supplyPos]--;
    #####:  304:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  305:
    #####:  306:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  307:    state->numBuys--;
    #####:  308:    if (DEBUG)
        -:  309:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  310:  }
        -:  311:
        -:  312:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  313:  //state->discardCount[who]++;
        -:  314:
    #####:  315:  return 0;
        -:  316:}
        -:  317:
    #####:  318:int numHandCards(struct gameState *state) {
    #####:  319:  return state->handCount[ whoseTurn(state) ];
        -:  320:}
        -:  321:
    #####:  322:int handCard(int handPos, struct gameState *state) {
    #####:  323:  int currentPlayer = whoseTurn(state);
    #####:  324:  return state->hand[currentPlayer][handPos];
        -:  325:}
        -:  326:
    #####:  327:int supplyCount(int card, struct gameState *state) {
    #####:  328:  return state->supplyCount[card];
        -:  329:}
        -:  330:
       26:  331:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  332:  int i;
       26:  333:  int count = 0;
        -:  334:
      341:  335:  for (i = 0; i < state->deckCount[player]; i++)
        -:  336:    {
      315:  337:      if (state->deck[player][i] == card) count++;
        -:  338:    }
        -:  339:
      253:  340:  for (i = 0; i < state->handCount[player]; i++)
        -:  341:    {
      227:  342:      if (state->hand[player][i] == card) count++;
        -:  343:    }
        -:  344:
       90:  345:  for (i = 0; i < state->discardCount[player]; i++)
        -:  346:    {
       64:  347:      if (state->discard[player][i] == card) count++;
        -:  348:    }
        -:  349:
       26:  350:  return count;
        -:  351:}
        -:  352:
    #####:  353:int whoseTurn(struct gameState *state) {
    #####:  354:  return state->whoseTurn;
        -:  355:}
        -:  356:
    #####:  357:int endTurn(struct gameState *state) {
        -:  358:  int k;
        -:  359:  int i;
    #####:  360:  int currentPlayer = whoseTurn(state);
        -:  361:
        -:  362:  //Discard hand
    #####:  363:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  364:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  365:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  366:  }
    #####:  367:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  368:
        -:  369:  //Code for determining the player
    #####:  370:  if (currentPlayer < (state->numPlayers - 1)){
    #####:  371:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  372:  }
        -:  373:  else{
    #####:  374:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  375:  }
        -:  376:
    #####:  377:  state->outpostPlayed = 0;
    #####:  378:  state->phase = 0;
    #####:  379:  state->numActions = 1;
    #####:  380:  state->coins = 0;
    #####:  381:  state->numBuys = 1;
    #####:  382:  state->playedCardCount = 0;
    #####:  383:  state->handCount[state->whoseTurn] = 0;
        -:  384:
        -:  385:  //int k; move to top
        -:  386:  //Next player draws hand
    #####:  387:  for (k = 0; k < 5; k++){
    #####:  388:    drawCard(state->whoseTurn, state);//Draw a card
        -:  389:  }
        -:  390:
        -:  391:  //Update money
    #####:  392:  updateCoins(state->whoseTurn, state , 0);
        -:  393:
    #####:  394:  return 0;
        -:  395:}
        -:  396:
        5:  397:int isGameOver(struct gameState *state) {
        -:  398:  int i;
        -:  399:  int j;
        -:  400:
        -:  401:  //if stack of Province cards is empty, the game ends
        5:  402:  if (state->supplyCount[province] == 0)
        -:  403:    {
        1:  404:      return 1;
        -:  405:    }
        -:  406:
        -:  407:  //if three supply pile are at 0, the game ends
        4:  408:  j = 0;
      104:  409:  for (i = 0; i < 25; i++)
        -:  410:    {
      100:  411:      if (state->supplyCount[i] == 0)
        -:  412:	{
        6:  413:	  j++;
        -:  414:	}
        -:  415:    }
        4:  416:  if ( j >= 3)
        -:  417:    {
        1:  418:      return 1;
        -:  419:    }
        -:  420:
        3:  421:  return 0;
        -:  422:}
        -:  423:
        2:  424:int scoreFor (int player, struct gameState *state) {
        -:  425:
        -:  426:  int i;
        2:  427:  int score = 0;
        -:  428:  //score from hand
        7:  429:  for (i = 0; i < state->handCount[player]; i++)
        -:  430:    {
        5:  431:      if (state->hand[player][i] == curse) { score = score - 1; };
        5:  432:      if (state->hand[player][i] == estate) { score = score + 1; };
        5:  433:      if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  434:      if (state->hand[player][i] == province) { score = score + 6; };
        5:  435:      if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  436:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  437:    }
        -:  438:
        -:  439:  //score from discard
       10:  440:  for (i = 0; i < state->discardCount[player]; i++)
        -:  441:    {
        8:  442:      if (state->discard[player][i] == curse) { score = score - 1; };
        8:  443:      if (state->discard[player][i] == estate) { score = score + 1; };
        8:  444:      if (state->discard[player][i] == duchy) { score = score + 3; };
        8:  445:      if (state->discard[player][i] == province) { score = score + 6; };
        8:  446:      if (state->discard[player][i] == great_hall) { score = score + 1; };
        8:  447:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  448:    }
        -:  449:
        -:  450:  //score from deck
       10:  451:  for (i = 0; i < state->discardCount[player]; i++)
        -:  452:    {
        8:  453:      if (state->deck[player][i] == curse) { score = score - 1; };
        8:  454:      if (state->deck[player][i] == estate) { score = score + 1; };
        8:  455:      if (state->deck[player][i] == duchy) { score = score + 3; };
        8:  456:      if (state->deck[player][i] == province) { score = score + 6; };
        8:  457:      if (state->deck[player][i] == great_hall) { score = score + 1; };
        8:  458:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  459:    }
        -:  460:
        2:  461:  return score;
        -:  462:}
        -:  463:
    #####:  464:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  465:  int i;
        -:  466:  int j;
        -:  467:  int highScore;
        -:  468:  int currentPlayer;
        -:  469:
        -:  470:  //get score for each player
    #####:  471:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  472:    {
        -:  473:      //set unused player scores to -9999
    #####:  474:      if (i >= state->numPlayers)
        -:  475:	{
    #####:  476:	  players[i] = -9999;
        -:  477:	}
        -:  478:      else
        -:  479:	{
    #####:  480:	  players[i] = scoreFor (i, state);
        -:  481:	}
        -:  482:    }
        -:  483:
        -:  484:  //find highest score
    #####:  485:  j = 0;
    #####:  486:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  487:    {
    #####:  488:      if (players[i] > players[j])
        -:  489:	{
    #####:  490:	  j = i;
        -:  491:	}
        -:  492:    }
    #####:  493:  highScore = players[j];
        -:  494:
        -:  495:  //add 1 to players who had less turns
    #####:  496:  currentPlayer = whoseTurn(state);
    #####:  497:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  498:    {
    #####:  499:      if ( players[i] == highScore && i > currentPlayer )
        -:  500:	{
    #####:  501:	  players[i]++;
        -:  502:	}
        -:  503:    }
        -:  504:
        -:  505:  //find new highest score
    #####:  506:  j = 0;
    #####:  507:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  508:    {
    #####:  509:      if ( players[i] > players[j] )
        -:  510:	{
    #####:  511:	  j = i;
        -:  512:	}
        -:  513:    }
    #####:  514:  highScore = players[j];
        -:  515:
        -:  516:  //set winners in array to 1 and rest to 0
    #####:  517:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  518:    {
    #####:  519:      if ( players[i] == highScore )
        -:  520:	{
    #####:  521:	  players[i] = 1;
        -:  522:	}
        -:  523:      else
        -:  524:	{
    #####:  525:	  players[i] = 0;
        -:  526:	}
        -:  527:    }
        -:  528:
    #####:  529:  return 0;
        -:  530:}
        -:  531:
    16701:  532:int drawCard(int player, struct gameState *state)
        -:  533:{	int count;
        -:  534:  int deckCounter;
    16701:  535:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  536:
        -:  537:    //Step 1 Shuffle the discard pile back into a deck
        -:  538:    int i;
        -:  539:    //Move discard to deck
     9791:  540:    for (i = 0; i < state->discardCount[player];i++){
     9701:  541:      state->deck[player][i] = state->discard[player][i];
     9701:  542:      state->discard[player][i] = -1;
        -:  543:    }
        -:  544:
       90:  545:    state->deckCount[player] = state->discardCount[player];
       90:  546:    state->discardCount[player] = 0;//Reset discard
        -:  547:
        -:  548:    //Shufffle the deck
       90:  549:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  550:
       90:  551:    if (DEBUG){//Debug statements
        -:  552:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  553:    }
        -:  554:
       90:  555:    state->discardCount[player] = 0;
        -:  556:
        -:  557:    //Step 2 Draw Card
       90:  558:    count = state->handCount[player];//Get current player's hand count
        -:  559:
       90:  560:    if (DEBUG){//Debug statements
        -:  561:      printf("Current hand count: %d\n", count);
        -:  562:    }
        -:  563:
       90:  564:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  565:
       90:  566:    if (deckCounter == 0)
    #####:  567:      return -1;
        -:  568:
       90:  569:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       90:  570:    state->deckCount[player]--;
       90:  571:    state->handCount[player]++;//Increment hand count
        -:  572:  }
        -:  573:
        -:  574:  else{
    16611:  575:    int count = state->handCount[player];//Get current hand count for player
        -:  576:    int deckCounter;
    16611:  577:    if (DEBUG){//Debug statements
        -:  578:      printf("Current hand count: %d\n", count);
        -:  579:    }
        -:  580:
    16611:  581:    deckCounter = state->deckCount[player];//Create holder for the deck count
    16611:  582:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    16611:  583:    state->deckCount[player]--;
    16611:  584:    state->handCount[player]++;//Increment hand count
        -:  585:  }
        -:  586:
    16701:  587:  return 0;
        -:  588:}
        -:  589:
        -:  590:// PLAY CARD FUNCTIONS ----------------------------------------------------------------------------------------------
        -:  591://
        -:  592:// PLAY ADVENTURER
        -:  593://
        -:  594:
      250:  595:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:  596:{
        -:  597:
     2800:  598:      while(drawntreasure<2){
     2300:  599:	if (state->deckCount[currentPlayer] <=1){//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
       13:  600:	  shuffle(currentPlayer, state);
        -:  601:	}
     2300:  602:	drawCard(currentPlayer, state);
     2300:  603:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     2550:  604:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
      250:  605:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:  606:	else{
     2050:  607:	  temphand[z]=cardDrawn;
     2050:  608:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
     2050:  609:	  z++;
        -:  610:	}
        -:  611:      }
     2550:  612:      while(z-1>=0){
     2050:  613:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     2050:  614:	z=z-1;
        -:  615:      }
      250:  616:      return 0;
        -:  617:}
        -:  618:
        -:  619://---------------------
        -:  620:// PLAY COUNCIL HALL
        -:  621://---------------------
     2250:  622:int playCouncRoom(struct gameState *state, int currentPlayer, int handPos)
        -:  623:{
        -:  624:    int i; // Needed to be declared under C99 standards, otherwise program breaks.
        -:  625:
        -:  626:    //+4 Cards ** REFACTORED TO 3 because of introduced bug.
    11250:  627:    for (i = 0; i < 4; ++i)
        -:  628:	{
     9000:  629:	  drawCard(currentPlayer, state);
        -:  630:	}
        -:  631:
        -:  632:      //+1 Buy
     2250:  633:      state->numBuys++;
        -:  634:
        -:  635:      //Each other player draws a card
     9500:  636:      for (i = 0; i < state->numPlayers; i++)
        -:  637:	{
     7250:  638:	  if ( i != currentPlayer )
        -:  639:	    {
     5000:  640:	      drawCard(i, state);
        -:  641:	    }
        -:  642:	}
        -:  643:
        -:  644:      //put played card in played card pile
     2250:  645:    discardCard(handPos, currentPlayer, state, 0);
        -:  646:
     2250:  647:    return 0;
        -:  648:}
        -:  649:
        -:  650://-------------------------------
        -:  651:// PLAY MINION
        -:  652://-------------------------------
        -:  653:
    #####:  654:int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:  655:{
        -:  656:
        -:  657:    int i, j;
        -:  658:
        -:  659:
        -:  660:      //+1 action
    #####:  661:      state->numActions--;
        -:  662:
        -:  663:      //discard card from hand
    #####:  664:      discardCard(handPos, currentPlayer, state, 0);
        -:  665:
    #####:  666:      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
        -:  667:	{
    #####:  668:	  state->coins = state->coins - 2;
        -:  669:	}
        -:  670:
    #####:  671:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  672:	{
        -:  673:
        -:  674://	  //discard hand ** COMMENTED OUT FOR REFACTORING
        -:  675://	  while(numHandCards(state) > 0)
        -:  676://	    {
        -:  677://	      discardCard(handPos, currentPlayer, state, 0);
        -:  678://	    }
        -:  679:
        -:  680:	  //draw 4 *** REFACTORED TO DRAW 3
    #####:  681:	  for (i = 0; i < 3; i++)
        -:  682:	    {
    #####:  683:	      drawCard(currentPlayer, state);
        -:  684:	    }
        -:  685:
        -:  686:	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
    #####:  687:	  for (i = 0; i < state->numPlayers; i++)
        -:  688:	    {
    #####:  689:	      if (i != currentPlayer)
        -:  690:		{
    #####:  691:		  if ( state->handCount[i] > 4 )
        -:  692:		    {
        -:  693:		    //  //discard hand
        -:  694:		    //  while( state->handCount[i] > 0 )
        -:  695:			// {
        -:  696:			//  discardCard(handPos, i, state, 0);
        -:  697:			// }
        -:  698:
        -:  699:		      //draw 4 ** REFACTOR: 3
    #####:  700:		      for (j = 0; j < 3; j++)
        -:  701:			{
    #####:  702:			  drawCard(i, state);
        -:  703:			}
        -:  704:		    }
        -:  705:		}
        -:  706:	    }
        -:  707:
        -:  708:	}
    #####:  709:      return 0;
        -:  710:
        -:  711:}
        -:  712:
        -:  713://-------------------------------
        -:  714:// PLAY SMITHY
        -:  715://-------------------------------
        -:  716:
        2:  717:int playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  718:{
        -:  719:
        -:  720:    int i;
        -:  721:
        -:  722://+3 Cards  *** REFACTOR changes i++ to ++i, breaks the intent of the card.
        8:  723:      for (i = 0; i < 3; ++i)
        -:  724:	{
        6:  725:	  drawCard(currentPlayer, state);
        -:  726:	}
        -:  727:      //discard card from hand
        2:  728:      discardCard(handPos, currentPlayer, state, 0);
        2:  729:      return 0;
        -:  730:}
        -:  731:
        -:  732:
        -:  733://-------------------------------
        -:  734:// VILLAGE
        -:  735://-------------------------------
        -:  736:
      250:  737:int playVillage(struct gameState *state, int currentPlayer, int handPos)
        -:  738:{
        -:  739:      //+1 Card
      250:  740:      drawCard(currentPlayer, state);
        -:  741:
        -:  742:      //+2 Actions
      250:  743:      state->numActions = state->numActions + 2;
        -:  744:
        -:  745:      //discard played card from hand
        -:  746:      // discardCard(handPos, currentPlayer, state, 0);
      250:  747:      return 0;
        -:  748:
        -:  749:}
        -:  750:
        -:  751://---------------------------------
        -:  752:
    #####:  753:int getCost(int cardNumber)
        -:  754:{
    #####:  755:  switch( cardNumber )
        -:  756:    {
        -:  757:    case curse:
    #####:  758:      return 0;
        -:  759:    case estate:
    #####:  760:      return 2;
        -:  761:    case duchy:
    #####:  762:      return 5;
        -:  763:    case province:
    #####:  764:      return 8;
        -:  765:    case copper:
    #####:  766:      return 0;
        -:  767:    case silver:
    #####:  768:      return 3;
        -:  769:    case gold:
    #####:  770:      return 6;
        -:  771:    case adventurer:
    #####:  772:      return 6;
        -:  773:    case council_room:
    #####:  774:      return 5;
        -:  775:    case feast:
    #####:  776:      return 4;
        -:  777:    case gardens:
    #####:  778:      return 4;
        -:  779:    case mine:
    #####:  780:      return 5;
        -:  781:    case remodel:
    #####:  782:      return 4;
        -:  783:    case smithy:
    #####:  784:      return 4;
        -:  785:    case village:
    #####:  786:      return 3;
        -:  787:    case baron:
    #####:  788:      return 4;
        -:  789:    case great_hall:
    #####:  790:      return 3;
        -:  791:    case minion:
    #####:  792:      return 5;
        -:  793:    case steward:
    #####:  794:      return 3;
        -:  795:    case tribute:
    #####:  796:      return 5;
        -:  797:    case ambassador:
    #####:  798:      return 3;
        -:  799:    case cutpurse:
    #####:  800:      return 4;
        -:  801:    case embargo:
    #####:  802:      return 2;
        -:  803:    case outpost:
    #####:  804:      return 5;
        -:  805:    case salvager:
    #####:  806:      return 4;
        -:  807:    case sea_hag:
    #####:  808:      return 4;
        -:  809:    case treasure_map:
    #####:  810:      return 4;
        -:  811:    }
        -:  812:
    #####:  813:  return -1;
        -:  814:}
        -:  815:
    #####:  816:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  817:{
        -:  818:  int i;
        -:  819:  int j;
        -:  820:  int k;
        -:  821:  int x;
        -:  822:  int index;
    #####:  823:  int currentPlayer = whoseTurn(state);
    #####:  824:  int nextPlayer = currentPlayer + 1;
        -:  825:
    #####:  826:  int tributeRevealedCards[2] = {-1, -1};
        -:  827:  int temphand[MAX_HAND];// moved above the if statement
    #####:  828:  int drawntreasure=0;
        -:  829:  int cardDrawn;
    #####:  830:  int z = 0;// this is the counter for the temp hand
    #####:  831:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  832:    nextPlayer = 0;
        -:  833:  }
        -:  834:
        -:  835:
    #####:  836:switch(card)
        -:  837:{
        -:  838://------------------------------------------------------------------------------
        -:  839:// Refactored cards/card function calls.
        -:  840:
        -:  841://----------------------------
        -:  842:// ADVENTURER
        -:  843:    case adventurer:
    #####:  844:        playAdventurer(state, currentPlayer, cardDrawn, drawntreasure, temphand, z);
    #####:  845:        break;
        -:  846://----------------------------
        -:  847:
        -:  848:
        -:  849://--------------------------------
        -:  850:// COUNCIL ROOM
        -:  851:    case council_room:
    #####:  852:        playCouncRoom(state, currentPlayer, handPos);
    #####:  853:        break;
        -:  854://---------------------------------
        -:  855:
        -:  856://---------------------------
        -:  857:// MINION
        -:  858://---------------------------
        -:  859:
        -:  860:    case minion:
    #####:  861:        playMinion(state, choice1, choice2, currentPlayer, handPos);
    #####:  862:        break;
        -:  863://--------------------------------
        -:  864:
        -:  865://-------------------------
        -:  866:// SMITHY
        -:  867://-------------------------
        -:  868:
        -:  869:case smithy:
    #####:  870:      playSmithy(state, currentPlayer, handPos);
    #####:  871:      break;
        -:  872:
        -:  873://-------------------------
        -:  874:
        -:  875://-------------------------
        -:  876:// VILLAGE
        -:  877://-------------------------
        -:  878:
        -:  879:case village:
    #####:  880:    playVillage(state, currentPlayer, handPos);
    #####:  881:    break;
        -:  882:
        -:  883://-------------------------
        -:  884:    case feast:
        -:  885:      //gain card with cost up to 5
        -:  886:      //Backup hand
    #####:  887:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  888:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  889:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  890:      }
        -:  891:      //Backup hand
        -:  892:
        -:  893:      //Update Coins for Buy
    #####:  894:      updateCoins(currentPlayer, state, 5);
    #####:  895:      x = 1;//Condition to loop on
    #####:  896:      while( x == 1) {//Buy one card
    #####:  897:	if (supplyCount(choice1, state) <= 0){
    #####:  898:	  if (DEBUG)
        -:  899:	    printf("None of that card left, sorry!\n");
        -:  900:
    #####:  901:	  if (DEBUG){
        -:  902:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  903:	  }
        -:  904:	}
    #####:  905:	else if (state->coins < getCost(choice1)){
    #####:  906:	  printf("That card is too expensive!\n");
        -:  907:
    #####:  908:	  if (DEBUG){
        -:  909:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  910:	  }
        -:  911:	}
        -:  912:	else{
        -:  913:
    #####:  914:	  if (DEBUG){
        -:  915:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  916:	  }
        -:  917:
    #####:  918:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  919:	  x = 0;//No more buying cards
        -:  920:
    #####:  921:	  if (DEBUG){
        -:  922:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  923:	  }
        -:  924:
        -:  925:	}
        -:  926:      }
        -:  927:
        -:  928:      //Reset Hand
    #####:  929:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  930:	state->hand[currentPlayer][i] = temphand[i];
    #####:  931:	temphand[i] = -1;
        -:  932:      }
        -:  933:      //Reset Hand
        -:  934:
    #####:  935:      return 0;
        -:  936:
        -:  937:    case gardens:
    #####:  938:      return -1;
        -:  939:
        -:  940:    case mine:
    #####:  941:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  942:
    #####:  943:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  944:	{
    #####:  945:	  return -1;
        -:  946:	}
        -:  947:
    #####:  948:      if (choice2 > treasure_map || choice2 < curse)
        -:  949:	{
    #####:  950:	  return -1;
        -:  951:	}
        -:  952:
    #####:  953:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  954:	{
    #####:  955:	  return -1;
        -:  956:	}
        -:  957:
    #####:  958:      gainCard(choice2, state, 2, currentPlayer);
        -:  959:
        -:  960:      //discard card from hand
    #####:  961:      discardCard(handPos, currentPlayer, state, 0);
        -:  962:
        -:  963:      //discard trashed card
    #####:  964:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  965:	{
    #####:  966:	  if (state->hand[currentPlayer][i] == j)
        -:  967:	    {
    #####:  968:	      discardCard(i, currentPlayer, state, 0);
    #####:  969:	      break;
        -:  970:	    }
        -:  971:	}
        -:  972:
    #####:  973:      return 0;
        -:  974:
        -:  975:    case remodel:
    #####:  976:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  977:
    #####:  978:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  979:	{
    #####:  980:	  return -1;
        -:  981:	}
        -:  982:
    #####:  983:      gainCard(choice2, state, 0, currentPlayer);
        -:  984:
        -:  985:      //discard card from hand
    #####:  986:      discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        -:  988:      //discard trashed card
    #####:  989:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  990:	{
    #####:  991:	  if (state->hand[currentPlayer][i] == j)
        -:  992:	    {
    #####:  993:	      discardCard(i, currentPlayer, state, 0);
    #####:  994:	      break;
        -:  995:	    }
        -:  996:	}
        -:  997:
        -:  998:
    #####:  999:      return 0;
        -: 1000:
        -: 1001: case baron:
    #####: 1002:      state->numBuys++;//Increase buys by 1!
    #####: 1003:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####: 1004:	int p = 0;//Iterator for hand!
    #####: 1005:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1006:	while(card_not_discarded){
    #####: 1007:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####: 1008:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1009:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1010:	    state->discardCount[currentPlayer]++;
    #####: 1011:	    for (;p < state->handCount[currentPlayer]; p++){
    #####: 1012:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1013:	    }
    #####: 1014:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1015:	    state->handCount[currentPlayer]--;
    #####: 1016:	    card_not_discarded = 0;//Exit the loop
        -: 1017:	  }
    #####: 1018:	  else if (p > state->handCount[currentPlayer]){
    #####: 1019:	    if(DEBUG) {
        -: 1020:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1021:	      printf("Must gain an estate if there are any\n");
        -: 1022:	    }
    #####: 1023:	    if (supplyCount(estate, state) > 0){
    #####: 1024:	      gainCard(estate, state, 0, currentPlayer);
    #####: 1025:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1026:	      if (supplyCount(estate, state) == 0){
    #####: 1027:		isGameOver(state);
        -: 1028:	      }
        -: 1029:	    }
    #####: 1030:	    card_not_discarded = 0;//Exit the loop
        -: 1031:	  }
        -: 1032:
        -: 1033:	  else{
    #####: 1034:	    p++;//Next card
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:
        -: 1039:      else{
    #####: 1040:	if (supplyCount(estate, state) > 0){
    #####: 1041:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####: 1042:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1043:	  if (supplyCount(estate, state) == 0){
    #####: 1044:	    isGameOver(state);
        -: 1045:	  }
        -: 1046:	}
        -: 1047:      }
        -: 1048:
        -: 1049:
    #####: 1050:      return 0;
        -: 1051:
        -: 1052:
        -: 1053:
        -: 1054:    case great_hall:
        -: 1055:      //+1 Card
    #####: 1056:      drawCard(currentPlayer, state);
        -: 1057:
        -: 1058:      //+1 Actions
    #####: 1059:      state->numActions++;
        -: 1060:
        -: 1061:      //discard card from hand
    #####: 1062:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1063:      return 0;
        -: 1064:
        -: 1065:    case steward:
    #####: 1066:      if (choice1 == 1)
        -: 1067:	{
        -: 1068:	  //+2 cards
    #####: 1069:	  drawCard(currentPlayer, state);
    #####: 1070:	  drawCard(currentPlayer, state);
        -: 1071:	}
    #####: 1072:      else if (choice1 == 2)
        -: 1073:	{
        -: 1074:	  //+2 coins
    #####: 1075:	  state->coins = state->coins + 2;
        -: 1076:	}
        -: 1077:      else
        -: 1078:	{
        -: 1079:	  //trash 2 cards in hand
    #####: 1080:	  discardCard(choice2, currentPlayer, state, 1);
    #####: 1081:	  discardCard(choice3, currentPlayer, state, 1);
        -: 1082:	}
        -: 1083:
        -: 1084:      //discard card from hand
    #####: 1085:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1086:      return 0;
        -: 1087:
        -: 1088:    case tribute:
    #####: 1089:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1090:	if (state->deckCount[nextPlayer] > 0){
    #####: 1091:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1092:	  state->deckCount[nextPlayer]--;
        -: 1093:	}
    #####: 1094:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1095:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1096:	  state->discardCount[nextPlayer]--;
        -: 1097:	}
        -: 1098:	else{
        -: 1099:	  //No Card to Reveal
    #####: 1100:	  if (DEBUG){
        -: 1101:	    printf("No cards to reveal\n");
        -: 1102:	  }
        -: 1103:	}
        -: 1104:      }
        -: 1105:
        -: 1106:      else{
    #####: 1107:	if (state->deckCount[nextPlayer] == 0){
    #####: 1108:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1109:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1110:	    state->deckCount[nextPlayer]++;
    #####: 1111:	    state->discard[nextPlayer][i] = -1;
    #####: 1112:	    state->discardCount[nextPlayer]--;
        -: 1113:	  }
        -: 1114:
    #####: 1115:	  shuffle(nextPlayer,state);//Shuffle the deck
        -: 1116:	}
    #####: 1117:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1118:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1119:	state->deckCount[nextPlayer]--;
    #####: 1120:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1121:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1122:	state->deckCount[nextPlayer]--;
        -: 1123:      }
        -: 1124:
    #####: 1125:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
    #####: 1126:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1127:	state->playedCardCount++;
    #####: 1128:	tributeRevealedCards[1] = -1;
        -: 1129:      }
        -: 1130:
    #####: 1131:      for (i = 0; i <= 2; i ++){
    #####: 1132:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1133:	  state->coins += 2;
        -: 1134:	}
        -: 1135:
    #####: 1136:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1137:	  drawCard(currentPlayer, state);
    #####: 1138:	  drawCard(currentPlayer, state);
        -: 1139:	}
        -: 1140:	else{//Action Card
    #####: 1141:	  state->numActions = state->numActions + 2;
        -: 1142:	}
        -: 1143:      }
        -: 1144:
    #####: 1145:      return 0;
        -: 1146:
        -: 1147:    case ambassador:
    #####: 1148:      j = 0;		//used to check if player has enough cards to discard
        -: 1149:
    #####: 1150:      if (choice2 > 2 || choice2 < 0)
        -: 1151:	{
    #####: 1152:	  return -1;
        -: 1153:	}
        -: 1154:
    #####: 1155:      if (choice1 == handPos)
        -: 1156:	{
    #####: 1157:	  return -1;
        -: 1158:	}
        -: 1159:
    #####: 1160:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:	{
    #####: 1162:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1163:	    {
    #####: 1164:	      j++;
        -: 1165:	    }
        -: 1166:	}
    #####: 1167:      if (j < choice2)
        -: 1168:	{
    #####: 1169:	  return -1;
        -: 1170:	}
        -: 1171:
    #####: 1172:      if (DEBUG)
        -: 1173:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1174:
        -: 1175:      //increase supply count for choosen card by amount being discarded
    #####: 1176:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1177:
        -: 1178:      //each other player gains a copy of revealed card
    #####: 1179:      for (i = 0; i < state->numPlayers; i++)
        -: 1180:	{
    #####: 1181:	  if (i != currentPlayer)
        -: 1182:	    {
    #####: 1183:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1184:	    }
        -: 1185:	}
        -: 1186:
        -: 1187:      //discard played card from hand
    #####: 1188:      discardCard(handPos, currentPlayer, state, 0);
        -: 1189:
        -: 1190:      //trash copies of cards returned to supply
    #####: 1191:      for (j = 0; j < choice2; j++)
        -: 1192:	{
    #####: 1193:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1194:	    {
    #####: 1195:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1196:		{
    #####: 1197:		  discardCard(i, currentPlayer, state, 1);
    #####: 1198:		  break;
        -: 1199:		}
        -: 1200:	    }
        -: 1201:	}
        -: 1202:
    #####: 1203:      return 0;
        -: 1204:
        -: 1205:    case cutpurse:
        -: 1206:
    #####: 1207:      updateCoins(currentPlayer, state, 2);
    #####: 1208:      for (i = 0; i < state->numPlayers; i++)
        -: 1209:	{
    #####: 1210:	  if (i != currentPlayer)
        -: 1211:	    {
    #####: 1212:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1213:		{
    #####: 1214:		  if (state->hand[i][j] == copper)
        -: 1215:		    {
    #####: 1216:		      discardCard(j, i, state, 0);
    #####: 1217:		      break;
        -: 1218:		    }
    #####: 1219:		  if (j == state->handCount[i])
        -: 1220:		    {
    #####: 1221:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1222:			{
    #####: 1223:			  if (DEBUG)
        -: 1224:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1225:			}
    #####: 1226:		      break;
        -: 1227:		    }
        -: 1228:		}
        -: 1229:
        -: 1230:	    }
        -: 1231:
        -: 1232:	}
        -: 1233:
        -: 1234:      //discard played card from hand
    #####: 1235:      discardCard(handPos, currentPlayer, state, 0);
        -: 1236:
    #####: 1237:      return 0;
        -: 1238:
        -: 1239:
        -: 1240:    case embargo:
        -: 1241:      //+2 Coins
    #####: 1242:      state->coins = state->coins + 2;
        -: 1243:
        -: 1244:      //see if selected pile is in play
    #####: 1245:      if ( state->supplyCount[choice1] == -1 )
        -: 1246:	{
    #####: 1247:	  return -1;
        -: 1248:	}
        -: 1249:
        -: 1250:      //add embargo token to selected supply pile
    #####: 1251:      state->embargoTokens[choice1]++;
        -: 1252:
        -: 1253:      //trash card
    #####: 1254:      discardCard(handPos, currentPlayer, state, 1);
    #####: 1255:      return 0;
        -: 1256:
        -: 1257:    case outpost:
        -: 1258:      //set outpost flag
    #####: 1259:      state->outpostPlayed++;
        -: 1260:
        -: 1261:      //discard card
    #####: 1262:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1263:      return 0;
        -: 1264:
        -: 1265:    case salvager:
        -: 1266:      //+1 buy
    #####: 1267:      state->numBuys++;
        -: 1268:
    #####: 1269:      if (choice1)
        -: 1270:	{
        -: 1271:	  //gain coins equal to trashed card
    #####: 1272:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1273:	  //trash card
    #####: 1274:	  discardCard(choice1, currentPlayer, state, 1);
        -: 1275:	}
        -: 1276:
        -: 1277:      //discard card
    #####: 1278:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1279:      return 0;
        -: 1280:
        -: 1281:    case sea_hag:
    #####: 1282:      for (i = 0; i < state->numPlayers; i++){
    #####: 1283:	if (i != currentPlayer){
    #####: 1284:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1285:	  state->discardCount[i]++;
    #####: 1286:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1287:	}
        -: 1288:      }
    #####: 1289:      return 0;
        -: 1290:
        -: 1291:    case treasure_map:
        -: 1292:      //search hand for another treasure_map
    #####: 1293:      index = -1;
    #####: 1294:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1295:	{
    #####: 1296:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1297:	    {
    #####: 1298:	      index = i;
    #####: 1299:	      break;
        -: 1300:	    }
        -: 1301:	}
    #####: 1302:      if (index > -1)
        -: 1303:	{
        -: 1304:	  //trash both treasure cards
    #####: 1305:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1306:	  discardCard(index, currentPlayer, state, 1);
        -: 1307:
        -: 1308:	  //gain 4 Gold cards
    #####: 1309:	  for (i = 0; i < 4; i++)
        -: 1310:	    {
    #####: 1311:	      gainCard(gold, state, 1, currentPlayer);
        -: 1312:	    }
        -: 1313:
        -: 1314:	  //return success
    #####: 1315:	  return 1;
        -: 1316:	}
        -: 1317:
        -: 1318:      //no second treasure_map found in hand
    #####: 1319:      return -1;
        -: 1320:    }
        -: 1321:
    #####: 1322:  return -1;
        -: 1323:}
        -: 1324:
     2252: 1325:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1326:{
        -: 1327:
        -: 1328:  //if card is not trashed, added to Played pile
     2252: 1329:  if (trashFlag < 1)
        -: 1330:    {
        -: 1331:      //add card to played pile
     2252: 1332:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
     2252: 1333:      state->playedCardCount++;
        -: 1334:    }
        -: 1335:
        -: 1336:  //set played card to -1
     2252: 1337:  state->hand[currentPlayer][handPos] = -1;
        -: 1338:
        -: 1339:  //remove card from player's hand
     2252: 1340:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1341:    {
        -: 1342:      //reduce number of cards in hand
    #####: 1343:      state->handCount[currentPlayer]--;
        -: 1344:    }
     2252: 1345:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1346:    {
        -: 1347:      //reduce number of cards in hand
    #####: 1348:      state->handCount[currentPlayer]--;
        -: 1349:    }
        -: 1350:  else
        -: 1351:    {
        -: 1352:      //replace discarded card with last card in hand
     2252: 1353:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1354:      //set last card to -1
     2252: 1355:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1356:      //reduce number of cards in hand
     2252: 1357:      state->handCount[currentPlayer]--;
        -: 1358:    }
        -: 1359:
     2252: 1360:  return 0;
        -: 1361:}
        -: 1362:
    #####: 1363:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1364:{
        -: 1365:  //Note: supplyPos is enum of choosen card
        -: 1366:
        -: 1367:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1368:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1369:    {
    #####: 1370:      return -1;
        -: 1371:    }
        -: 1372:
        -: 1373:  //added card for [whoseTurn] current player:
        -: 1374:  // toFlag = 0 : add to discard
        -: 1375:  // toFlag = 1 : add to deck
        -: 1376:  // toFlag = 2 : add to hand
        -: 1377:
    #####: 1378:  if (toFlag == 1)
        -: 1379:    {
    #####: 1380:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1381:      state->deckCount[player]++;
        -: 1382:    }
    #####: 1383:  else if (toFlag == 2)
        -: 1384:    {
    #####: 1385:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1386:      state->handCount[player]++;
        -: 1387:    }
        -: 1388:  else
        -: 1389:    {
    #####: 1390:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1391:      state->discardCount[player]++;
        -: 1392:    }
        -: 1393:
        -: 1394:  //decrease number in supply pile
    #####: 1395:  state->supplyCount[supplyPos]--;
        -: 1396:
    #####: 1397:  return 0;
        -: 1398:}
        -: 1399:
       53: 1400:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1401:{
        -: 1402:  int i;
        -: 1403:
        -: 1404:  //reset coin count
       53: 1405:  state->coins = 0;
        -: 1406:
        -: 1407:  //add coins for each Treasure card in player's hand
      318: 1408:  for (i = 0; i < state->handCount[player]; i++)
        -: 1409:    {
      265: 1410:      if (state->hand[player][i] == copper)
        -: 1411:	{
      174: 1412:	  state->coins += 1;
        -: 1413:	}
       91: 1414:      else if (state->hand[player][i] == silver)
        -: 1415:	{
       30: 1416:	  state->coins += 2;
        -: 1417:	}
       61: 1418:      else if (state->hand[player][i] == gold)
        -: 1419:	{
       30: 1420:	  state->coins += 3;
        -: 1421:	}
        -: 1422:    }
        -: 1423:
        -: 1424:  //add bonus
       53: 1425:  state->coins += bonus;
        -: 1426:
       53: 1427:  return 0;
        -: 1428:}
        -: 1429:
        -: 1430:
        -: 1431://end of dominion.c
        -: 1432:
File 'dominion.c'
Lines executed:35.13% of 575
Branches executed:38.74% of 413
Taken at least once:33.90% of 413
Calls executed:18.68% of 91
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:// Assignment 2, CS362-400-W16
        -:    2:// Andrew M. Calhoun
        -:    3:// calhouna@oregonstate.edu
        -:    4:// Due Date: 1/17/2016
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12:
        -:   13:
        -:   14:
function compare called 57910 returned 100% blocks executed 100%
    57910:   15:int compare(const void* a, const void* b) {
    57910:   16:  if (*(int*)a > *(int*)b)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    28735:   17:    return 1;
    29175:   18:  if (*(int*)a < *(int*)b)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    14977:   19:    return -1;
    14198:   20:  return 0;
        -:   21:}
        -:   22:
function newGame called 0 returned 0% blocks executed 0%
    #####:   23:struct gameState* newGame() {
    #####:   24:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   25:  return g;
        -:   26:}
        -:   27:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   28:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   29:		  int k8, int k9, int k10) {
    #####:   30:  int* k = malloc(10 * sizeof(int));
    #####:   31:  k[0] = k1;
    #####:   32:  k[1] = k2;
    #####:   33:  k[2] = k3;
    #####:   34:  k[3] = k4;
    #####:   35:  k[4] = k5;
    #####:   36:  k[5] = k6;
    #####:   37:  k[6] = k7;
    #####:   38:  k[7] = k8;
    #####:   39:  k[8] = k9;
    #####:   40:  k[9] = k10;
    #####:   41:  return k;
        -:   42:}
        -:   43:
function initializeGame called 29 returned 100% blocks executed 94%
       29:   44:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   45:		   struct gameState *state) {
        -:   46:
        -:   47:  int i;
        -:   48:  int j;
        -:   49:  int it;
        -:   50:  //set up random number generator
       29:   51:  SelectStream(1);
call    0 returned 100%
       29:   52:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   53:
        -:   54:  //check number of players
       29:   55:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   56:    {
    #####:   57:      return -1;
        -:   58:    }
        -:   59:
        -:   60:  //set number of players
       29:   61:  state->numPlayers = numPlayers;
        -:   62:
        -:   63:  //check selected kingdom cards are different
      319:   64:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   65:    {
     3190:   66:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   67:        {
     2900:   68:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   69:	    {
    #####:   70:	      return -1;
        -:   71:	    }
        -:   72:        }
        -:   73:    }
        -:   74:
        -:   75:
        -:   76:  //initialize supply
        -:   77:  ///////////////////////////////
        -:   78:
        -:   79:  //set number of Curse cards
       29:   80:  if (numPlayers == 2)
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -:   81:    {
       27:   82:      state->supplyCount[curse] = 10;
        -:   83:    }
        2:   84:  else if (numPlayers == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   85:    {
        2:   86:      state->supplyCount[curse] = 20;
        -:   87:    }
        -:   88:  else
        -:   89:    {
    #####:   90:      state->supplyCount[curse] = 30;
        -:   91:    }
        -:   92:
        -:   93:  //set number of Victory cards
       29:   94:  if (numPlayers == 2)
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -:   95:    {
       27:   96:      state->supplyCount[estate] = 8;
       27:   97:      state->supplyCount[duchy] = 8;
       27:   98:      state->supplyCount[province] = 8;
        -:   99:    }
        -:  100:  else
        -:  101:    {
        2:  102:      state->supplyCount[estate] = 12;
        2:  103:      state->supplyCount[duchy] = 12;
        2:  104:      state->supplyCount[province] = 12;
        -:  105:    }
        -:  106:
        -:  107:  //set number of Treasure cards
       29:  108:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       29:  109:  state->supplyCount[silver] = 40;
       29:  110:  state->supplyCount[gold] = 30;
        -:  111:
        -:  112:  //set number of Kingdom cards
      609:  113:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  114:    {
     4785:  115:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  116:	{
     4495:  117:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  118:	    {
        -:  119:	      //check if card is a 'Victory' Kingdom card
      345:  120:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  121:		{
       55:  122:		  if (numPlayers == 2){
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
       52:  123:		    state->supplyCount[i] = 8;
        -:  124:		  }
        3:  125:		  else{ state->supplyCount[i] = 12; }
        -:  126:		}
        -:  127:	      else
        -:  128:		{
      235:  129:		  state->supplyCount[i] = 10;
        -:  130:		}
      290:  131:	      break;
        -:  132:	    }
        -:  133:	  else    //card is not in the set choosen for the game
        -:  134:	    {
     4205:  135:	      state->supplyCount[i] = -1;
        -:  136:	    }
        -:  137:	}
        -:  138:
        -:  139:    }
        -:  140:
        -:  141:  ////////////////////////
        -:  142:  //supply initialization complete
        -:  143:
        -:  144:  //set player decks
       89:  145:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  146:    {
       60:  147:      state->deckCount[i] = 0;
      240:  148:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  149:	{
      180:  150:	  state->deck[i][j] = estate;
      180:  151:	  state->deckCount[i]++;
        -:  152:	}
      480:  153:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  154:	{
      420:  155:	  state->deck[i][j] = copper;
      420:  156:	  state->deckCount[i]++;
        -:  157:	}
        -:  158:    }
        -:  159:
        -:  160:  //shuffle player decks
       89:  161:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  162:    {
       60:  163:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  164:	{
    #####:  165:	  return -1;
        -:  166:	}
        -:  167:    }
        -:  168:
        -:  169:  //draw player hands
       89:  170:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  171:    {
        -:  172:      //initialize hand size to zero
       60:  173:      state->handCount[i] = 0;
       60:  174:      state->discardCount[i] = 0;
        -:  175:      //draw 5 cards
        -:  176:      // for (j = 0; j < 5; j++)
        -:  177:      //	{
        -:  178:      //	  drawCard(i, state);
        -:  179:      //	}
        -:  180:    }
        -:  181:
        -:  182:  //set embargo tokens to 0 for all supply piles
      812:  183:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  184:    {
      783:  185:      state->embargoTokens[i] = 0;
        -:  186:    }
        -:  187:
        -:  188:  //initialize first player's turn
       29:  189:  state->outpostPlayed = 0;
       29:  190:  state->phase = 0;
       29:  191:  state->numActions = 1;
       29:  192:  state->numBuys = 1;
       29:  193:  state->playedCardCount = 0;
       29:  194:  state->whoseTurn = 0;
       29:  195:  state->handCount[state->whoseTurn] = 0;
        -:  196:  //int it; move to top
        -:  197:
        -:  198:  //Moved draw cards to here, only drawing at the start of a turn
      174:  199:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      145:  200:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  201:  }
        -:  202:
       29:  203:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  204:
       29:  205:  return 0;
        -:  206:}
        -:  207:
function shuffle called 163 returned 100% blocks executed 100%
      163:  208:int shuffle(int player, struct gameState *state) {
        -:  209:
        -:  210:
        -:  211:  int newDeck[MAX_DECK];
      163:  212:  int newDeckPos = 0;
        -:  213:  int card;
        -:  214:  int i;
        -:  215:
      163:  216:  if (state->deckCount[player] < 1)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        6:  217:    return -1;
      157:  218:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  219:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  220:
    10622:  221:  while (state->deckCount[player] > 0) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
    10308:  222:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
    10308:  223:    newDeck[newDeckPos] = state->deck[player][card];
    10308:  224:    newDeckPos++;
   421685:  225:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
   411377:  226:      state->deck[player][i] = state->deck[player][i+1];
        -:  227:    }
    10308:  228:    state->deckCount[player]--;
        -:  229:  }
    10465:  230:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
    10308:  231:    state->deck[player][i] = newDeck[i];
    10308:  232:    state->deckCount[player]++;
        -:  233:  }
        -:  234:
      157:  235:  return 0;
        -:  236:}
        -:  237:
function playCard called 0 returned 0% blocks executed 0%
    #####:  238:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  239:{
        -:  240:  int card;
    #####:  241:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  242:
        -:  243:  //check if it is the right phase
    #####:  244:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:
        -:  249:  //check if player has enough actions
    #####:  250:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  251:    {
    #####:  252:      return -1;
        -:  253:    }
        -:  254:
        -:  255:  //get card played
    #####:  256:  card = handCard(handPos, state);
call    0 never executed
        -:  257:
        -:  258:  //check if selected card is an action
    #####:  259:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:
        -:  264:  //play card
    #####:  265:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  266:    {
    #####:  267:      return -1;
        -:  268:    }
        -:  269:
        -:  270:  //reduce number of actions
    #####:  271:  state->numActions--;
        -:  272:
        -:  273:  //update coins (Treasure cards may be added with card draws)
    #####:  274:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  275:
    #####:  276:  return 0;
        -:  277:}
        -:  278:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  279:int buyCard(int supplyPos, struct gameState *state) {
        -:  280:  int who;
    #####:  281:  if (DEBUG){
        -:  282:    printf("Entering buyCard...\n");
        -:  283:  }
        -:  284:
        -:  285:  // I don't know what to do about the phase thing.
        -:  286:
    #####:  287:  who = state->whoseTurn;
        -:  288:
    #####:  289:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
    #####:  290:    if (DEBUG)
        -:  291:      printf("You do not have any buys left\n");
    #####:  292:    return -1;
    #####:  293:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:    if (DEBUG)
        -:  295:      printf("There are not any of that type of card left\n");
    #####:  296:    return -1;
    #####:  297:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  298:    if (DEBUG)
        -:  299:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:    return -1;
        -:  301:  } else {
    #####:  302:    state->phase=1;
        -:  303:    //state->supplyCount[supplyPos]--;
    #####:  304:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  305:
    #####:  306:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  307:    state->numBuys--;
    #####:  308:    if (DEBUG)
        -:  309:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  310:  }
        -:  311:
        -:  312:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  313:  //state->discardCount[who]++;
        -:  314:
    #####:  315:  return 0;
        -:  316:}
        -:  317:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  318:int numHandCards(struct gameState *state) {
    #####:  319:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  320:}
        -:  321:
function handCard called 0 returned 0% blocks executed 0%
    #####:  322:int handCard(int handPos, struct gameState *state) {
    #####:  323:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  324:  return state->hand[currentPlayer][handPos];
        -:  325:}
        -:  326:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  327:int supplyCount(int card, struct gameState *state) {
    #####:  328:  return state->supplyCount[card];
        -:  329:}
        -:  330:
function fullDeckCount called 26 returned 100% blocks executed 100%
       26:  331:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  332:  int i;
       26:  333:  int count = 0;
        -:  334:
      341:  335:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  336:    {
      315:  337:      if (state->deck[player][i] == card) count++;
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        -:  338:    }
        -:  339:
      253:  340:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:  341:    {
      227:  342:      if (state->hand[player][i] == card) count++;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -:  343:    }
        -:  344:
       90:  345:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  346:    {
       64:  347:      if (state->discard[player][i] == card) count++;
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        -:  348:    }
        -:  349:
       26:  350:  return count;
        -:  351:}
        -:  352:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  353:int whoseTurn(struct gameState *state) {
    #####:  354:  return state->whoseTurn;
        -:  355:}
        -:  356:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  357:int endTurn(struct gameState *state) {
        -:  358:  int k;
        -:  359:  int i;
    #####:  360:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  361:
        -:  362:  //Discard hand
    #####:  363:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  364:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  365:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  366:  }
    #####:  367:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  368:
        -:  369:  //Code for determining the player
    #####:  370:  if (currentPlayer < (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  371:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  372:  }
        -:  373:  else{
    #####:  374:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  375:  }
        -:  376:
    #####:  377:  state->outpostPlayed = 0;
    #####:  378:  state->phase = 0;
    #####:  379:  state->numActions = 1;
    #####:  380:  state->coins = 0;
    #####:  381:  state->numBuys = 1;
    #####:  382:  state->playedCardCount = 0;
    #####:  383:  state->handCount[state->whoseTurn] = 0;
        -:  384:
        -:  385:  //int k; move to top
        -:  386:  //Next player draws hand
    #####:  387:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  388:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  389:  }
        -:  390:
        -:  391:  //Update money
    #####:  392:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  393:
    #####:  394:  return 0;
        -:  395:}
        -:  396:
function isGameOver called 5 returned 100% blocks executed 100%
        5:  397:int isGameOver(struct gameState *state) {
        -:  398:  int i;
        -:  399:  int j;
        -:  400:
        -:  401:  //if stack of Province cards is empty, the game ends
        5:  402:  if (state->supplyCount[province] == 0)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  403:    {
        1:  404:      return 1;
        -:  405:    }
        -:  406:
        -:  407:  //if three supply pile are at 0, the game ends
        4:  408:  j = 0;
      104:  409:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  410:    {
      100:  411:      if (state->supplyCount[i] == 0)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  412:	{
        6:  413:	  j++;
        -:  414:	}
        -:  415:    }
        4:  416:  if ( j >= 3)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  417:    {
        1:  418:      return 1;
        -:  419:    }
        -:  420:
        3:  421:  return 0;
        -:  422:}
        -:  423:
function scoreFor called 2 returned 100% blocks executed 73%
        2:  424:int scoreFor (int player, struct gameState *state) {
        -:  425:
        -:  426:  int i;
        2:  427:  int score = 0;
        -:  428:  //score from hand
        7:  429:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  430:    {
        5:  431:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5:  432:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        5:  433:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5:  434:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5:  435:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5:  436:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  437:    }
        -:  438:
        -:  439:  //score from discard
       10:  440:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  441:    {
        8:  442:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 taken 13% (fallthrough)
branch  1 taken 88%
        8:  443:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        8:  444:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 taken 13% (fallthrough)
branch  1 taken 88%
        8:  445:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        8:  446:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 taken 13% (fallthrough)
branch  1 taken 88%
        8:  447:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
call    2 returned 100%
        -:  448:    }
        -:  449:
        -:  450:  //score from deck
       10:  451:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  452:    {
        8:  453:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        8:  454:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 taken 38% (fallthrough)
branch  1 taken 63%
        8:  455:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        8:  456:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        8:  457:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        8:  458:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  459:    }
        -:  460:
        2:  461:  return score;
        -:  462:}
        -:  463:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  464:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  465:  int i;
        -:  466:  int j;
        -:  467:  int highScore;
        -:  468:  int currentPlayer;
        -:  469:
        -:  470:  //get score for each player
    #####:  471:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  472:    {
        -:  473:      //set unused player scores to -9999
    #####:  474:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  475:	{
    #####:  476:	  players[i] = -9999;
        -:  477:	}
        -:  478:      else
        -:  479:	{
    #####:  480:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  481:	}
        -:  482:    }
        -:  483:
        -:  484:  //find highest score
    #####:  485:  j = 0;
    #####:  486:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  487:    {
    #####:  488:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  489:	{
    #####:  490:	  j = i;
        -:  491:	}
        -:  492:    }
    #####:  493:  highScore = players[j];
        -:  494:
        -:  495:  //add 1 to players who had less turns
    #####:  496:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  497:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  498:    {
    #####:  499:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  500:	{
    #####:  501:	  players[i]++;
        -:  502:	}
        -:  503:    }
        -:  504:
        -:  505:  //find new highest score
    #####:  506:  j = 0;
    #####:  507:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  508:    {
    #####:  509:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  510:	{
    #####:  511:	  j = i;
        -:  512:	}
        -:  513:    }
    #####:  514:  highScore = players[j];
        -:  515:
        -:  516:  //set winners in array to 1 and rest to 0
    #####:  517:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  518:    {
    #####:  519:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  520:	{
    #####:  521:	  players[i] = 1;
        -:  522:	}
        -:  523:      else
        -:  524:	{
    #####:  525:	  players[i] = 0;
        -:  526:	}
        -:  527:    }
        -:  528:
    #####:  529:  return 0;
        -:  530:}
        -:  531:
function drawCard called 16701 returned 100% blocks executed 93%
    16701:  532:int drawCard(int player, struct gameState *state)
        -:  533:{	int count;
        -:  534:  int deckCounter;
    16701:  535:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  536:
        -:  537:    //Step 1 Shuffle the discard pile back into a deck
        -:  538:    int i;
        -:  539:    //Move discard to deck
     9791:  540:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     9701:  541:      state->deck[player][i] = state->discard[player][i];
     9701:  542:      state->discard[player][i] = -1;
        -:  543:    }
        -:  544:
       90:  545:    state->deckCount[player] = state->discardCount[player];
       90:  546:    state->discardCount[player] = 0;//Reset discard
        -:  547:
        -:  548:    //Shufffle the deck
       90:  549:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  550:
       90:  551:    if (DEBUG){//Debug statements
        -:  552:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  553:    }
        -:  554:
       90:  555:    state->discardCount[player] = 0;
        -:  556:
        -:  557:    //Step 2 Draw Card
       90:  558:    count = state->handCount[player];//Get current player's hand count
        -:  559:
       90:  560:    if (DEBUG){//Debug statements
        -:  561:      printf("Current hand count: %d\n", count);
        -:  562:    }
        -:  563:
       90:  564:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  565:
       90:  566:    if (deckCounter == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  567:      return -1;
        -:  568:
       90:  569:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       90:  570:    state->deckCount[player]--;
       90:  571:    state->handCount[player]++;//Increment hand count
        -:  572:  }
        -:  573:
        -:  574:  else{
    16611:  575:    int count = state->handCount[player];//Get current hand count for player
        -:  576:    int deckCounter;
    16611:  577:    if (DEBUG){//Debug statements
        -:  578:      printf("Current hand count: %d\n", count);
        -:  579:    }
        -:  580:
    16611:  581:    deckCounter = state->deckCount[player];//Create holder for the deck count
    16611:  582:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    16611:  583:    state->deckCount[player]--;
    16611:  584:    state->handCount[player]++;//Increment hand count
        -:  585:  }
        -:  586:
    16701:  587:  return 0;
        -:  588:}
        -:  589:
        -:  590:// PLAY CARD FUNCTIONS ----------------------------------------------------------------------------------------------
        -:  591://
        -:  592:// PLAY ADVENTURER
        -:  593://
        -:  594:
function playAdventurer called 250 returned 100% blocks executed 100%
      250:  595:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:  596:{
        -:  597:
     2800:  598:      while(drawntreasure<2){
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
     2300:  599:	if (state->deckCount[currentPlayer] <=1){//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       13:  600:	  shuffle(currentPlayer, state);
call    0 returned 100%
        -:  601:	}
     2300:  602:	drawCard(currentPlayer, state);
call    0 returned 100%
     2300:  603:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     2550:  604:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
      250:  605:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:  606:	else{
     2050:  607:	  temphand[z]=cardDrawn;
     2050:  608:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
     2050:  609:	  z++;
        -:  610:	}
        -:  611:      }
     2550:  612:      while(z-1>=0){
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
     2050:  613:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     2050:  614:	z=z-1;
        -:  615:      }
      250:  616:      return 0;
        -:  617:}
        -:  618:
        -:  619://---------------------
        -:  620:// PLAY COUNCIL HALL
        -:  621://---------------------
function playCouncRoom called 2250 returned 100% blocks executed 100%
     2250:  622:int playCouncRoom(struct gameState *state, int currentPlayer, int handPos)
        -:  623:{
        -:  624:    int i; // Needed to be declared under C99 standards, otherwise program breaks.
        -:  625:
        -:  626:    //+4 Cards ** REFACTORED TO 3 because of introduced bug.
    11250:  627:    for (i = 0; i < 4; ++i)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  628:	{
     9000:  629:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -:  630:	}
        -:  631:
        -:  632:      //+1 Buy
     2250:  633:      state->numBuys++;
        -:  634:
        -:  635:      //Each other player draws a card
     9500:  636:      for (i = 0; i < state->numPlayers; i++)
branch  0 taken 76%
branch  1 taken 24% (fallthrough)
        -:  637:	{
     7250:  638:	  if ( i != currentPlayer )
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -:  639:	    {
     5000:  640:	      drawCard(i, state);
call    0 returned 100%
        -:  641:	    }
        -:  642:	}
        -:  643:
        -:  644:      //put played card in played card pile
     2250:  645:    discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  646:
     2250:  647:    return 0;
        -:  648:}
        -:  649:
        -:  650://-------------------------------
        -:  651:// PLAY MINION
        -:  652://-------------------------------
        -:  653:
function playMinion called 0 returned 0% blocks executed 0%
    #####:  654:int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:  655:{
        -:  656:
        -:  657:    int i, j;
        -:  658:
        -:  659:
        -:  660:      //+1 action
    #####:  661:      state->numActions--;
        -:  662:
        -:  663:      //discard card from hand
    #####:  664:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  665:
    #####:  666:      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
branch  0 never executed
branch  1 never executed
        -:  667:	{
    #####:  668:	  state->coins = state->coins - 2;
        -:  669:	}
        -:  670:
    #####:  671:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  672:	{
        -:  673:
        -:  674://	  //discard hand ** COMMENTED OUT FOR REFACTORING
        -:  675://	  while(numHandCards(state) > 0)
        -:  676://	    {
        -:  677://	      discardCard(handPos, currentPlayer, state, 0);
        -:  678://	    }
        -:  679:
        -:  680:	  //draw 4 *** REFACTORED TO DRAW 3
    #####:  681:	  for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  682:	    {
    #####:  683:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  684:	    }
        -:  685:
        -:  686:	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
    #####:  687:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  688:	    {
    #####:  689:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  690:		{
    #####:  691:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  692:		    {
        -:  693:		    //  //discard hand
        -:  694:		    //  while( state->handCount[i] > 0 )
        -:  695:			// {
        -:  696:			//  discardCard(handPos, i, state, 0);
        -:  697:			// }
        -:  698:
        -:  699:		      //draw 4 ** REFACTOR: 3
    #####:  700:		      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  701:			{
    #####:  702:			  drawCard(i, state);
call    0 never executed
        -:  703:			}
        -:  704:		    }
        -:  705:		}
        -:  706:	    }
        -:  707:
        -:  708:	}
    #####:  709:      return 0;
        -:  710:
        -:  711:}
        -:  712:
        -:  713://-------------------------------
        -:  714:// PLAY SMITHY
        -:  715://-------------------------------
        -:  716:
function playSmithy called 2 returned 100% blocks executed 100%
        2:  717:int playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  718:{
        -:  719:
        -:  720:    int i;
        -:  721:
        -:  722://+3 Cards  *** REFACTOR changes i++ to ++i, breaks the intent of the card.
        8:  723:      for (i = 0; i < 3; ++i)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  724:	{
        6:  725:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -:  726:	}
        -:  727:      //discard card from hand
        2:  728:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        2:  729:      return 0;
        -:  730:}
        -:  731:
        -:  732:
        -:  733://-------------------------------
        -:  734:// VILLAGE
        -:  735://-------------------------------
        -:  736:
function playVillage called 250 returned 100% blocks executed 100%
      250:  737:int playVillage(struct gameState *state, int currentPlayer, int handPos)
        -:  738:{
        -:  739:      //+1 Card
      250:  740:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  741:
        -:  742:      //+2 Actions
      250:  743:      state->numActions = state->numActions + 2;
        -:  744:
        -:  745:      //discard played card from hand
        -:  746:      // discardCard(handPos, currentPlayer, state, 0);
      250:  747:      return 0;
        -:  748:
        -:  749:}
        -:  750:
        -:  751://---------------------------------
        -:  752:
function getCost called 0 returned 0% blocks executed 0%
    #####:  753:int getCost(int cardNumber)
        -:  754:{
    #####:  755:  switch( cardNumber )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  756:    {
        -:  757:    case curse:
    #####:  758:      return 0;
        -:  759:    case estate:
    #####:  760:      return 2;
        -:  761:    case duchy:
    #####:  762:      return 5;
        -:  763:    case province:
    #####:  764:      return 8;
        -:  765:    case copper:
    #####:  766:      return 0;
        -:  767:    case silver:
    #####:  768:      return 3;
        -:  769:    case gold:
    #####:  770:      return 6;
        -:  771:    case adventurer:
    #####:  772:      return 6;
        -:  773:    case council_room:
    #####:  774:      return 5;
        -:  775:    case feast:
    #####:  776:      return 4;
        -:  777:    case gardens:
    #####:  778:      return 4;
        -:  779:    case mine:
    #####:  780:      return 5;
        -:  781:    case remodel:
    #####:  782:      return 4;
        -:  783:    case smithy:
    #####:  784:      return 4;
        -:  785:    case village:
    #####:  786:      return 3;
        -:  787:    case baron:
    #####:  788:      return 4;
        -:  789:    case great_hall:
    #####:  790:      return 3;
        -:  791:    case minion:
    #####:  792:      return 5;
        -:  793:    case steward:
    #####:  794:      return 3;
        -:  795:    case tribute:
    #####:  796:      return 5;
        -:  797:    case ambassador:
    #####:  798:      return 3;
        -:  799:    case cutpurse:
    #####:  800:      return 4;
        -:  801:    case embargo:
    #####:  802:      return 2;
        -:  803:    case outpost:
    #####:  804:      return 5;
        -:  805:    case salvager:
    #####:  806:      return 4;
        -:  807:    case sea_hag:
    #####:  808:      return 4;
        -:  809:    case treasure_map:
    #####:  810:      return 4;
        -:  811:    }
        -:  812:
    #####:  813:  return -1;
        -:  814:}
        -:  815:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  816:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  817:{
        -:  818:  int i;
        -:  819:  int j;
        -:  820:  int k;
        -:  821:  int x;
        -:  822:  int index;
    #####:  823:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  824:  int nextPlayer = currentPlayer + 1;
        -:  825:
    #####:  826:  int tributeRevealedCards[2] = {-1, -1};
        -:  827:  int temphand[MAX_HAND];// moved above the if statement
    #####:  828:  int drawntreasure=0;
        -:  829:  int cardDrawn;
    #####:  830:  int z = 0;// this is the counter for the temp hand
    #####:  831:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  832:    nextPlayer = 0;
        -:  833:  }
        -:  834:
        -:  835:
    #####:  836:switch(card)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  837:{
        -:  838://------------------------------------------------------------------------------
        -:  839:// Refactored cards/card function calls.
        -:  840:
        -:  841://----------------------------
        -:  842:// ADVENTURER
        -:  843:    case adventurer:
    #####:  844:        playAdventurer(state, currentPlayer, cardDrawn, drawntreasure, temphand, z);
call    0 never executed
    #####:  845:        break;
        -:  846://----------------------------
        -:  847:
        -:  848:
        -:  849://--------------------------------
        -:  850:// COUNCIL ROOM
        -:  851:    case council_room:
    #####:  852:        playCouncRoom(state, currentPlayer, handPos);
call    0 never executed
    #####:  853:        break;
        -:  854://---------------------------------
        -:  855:
        -:  856://---------------------------
        -:  857:// MINION
        -:  858://---------------------------
        -:  859:
        -:  860:    case minion:
    #####:  861:        playMinion(state, choice1, choice2, currentPlayer, handPos);
call    0 never executed
    #####:  862:        break;
        -:  863://--------------------------------
        -:  864:
        -:  865://-------------------------
        -:  866:// SMITHY
        -:  867://-------------------------
        -:  868:
        -:  869:case smithy:
    #####:  870:      playSmithy(state, currentPlayer, handPos);
call    0 never executed
    #####:  871:      break;
        -:  872:
        -:  873://-------------------------
        -:  874:
        -:  875://-------------------------
        -:  876:// VILLAGE
        -:  877://-------------------------
        -:  878:
        -:  879:case village:
    #####:  880:    playVillage(state, currentPlayer, handPos);
call    0 never executed
    #####:  881:    break;
        -:  882:
        -:  883://-------------------------
        -:  884:    case feast:
        -:  885:      //gain card with cost up to 5
        -:  886:      //Backup hand
    #####:  887:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  888:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  889:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  890:      }
        -:  891:      //Backup hand
        -:  892:
        -:  893:      //Update Coins for Buy
    #####:  894:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  895:      x = 1;//Condition to loop on
    #####:  896:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  897:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:	  if (DEBUG)
        -:  899:	    printf("None of that card left, sorry!\n");
        -:  900:
    #####:  901:	  if (DEBUG){
        -:  902:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  903:	  }
        -:  904:	}
    #####:  905:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  906:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  907:
    #####:  908:	  if (DEBUG){
        -:  909:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  910:	  }
        -:  911:	}
        -:  912:	else{
        -:  913:
    #####:  914:	  if (DEBUG){
        -:  915:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  916:	  }
        -:  917:
    #####:  918:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  919:	  x = 0;//No more buying cards
        -:  920:
    #####:  921:	  if (DEBUG){
        -:  922:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  923:	  }
        -:  924:
        -:  925:	}
        -:  926:      }
        -:  927:
        -:  928:      //Reset Hand
    #####:  929:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  930:	state->hand[currentPlayer][i] = temphand[i];
    #####:  931:	temphand[i] = -1;
        -:  932:      }
        -:  933:      //Reset Hand
        -:  934:
    #####:  935:      return 0;
        -:  936:
        -:  937:    case gardens:
    #####:  938:      return -1;
        -:  939:
        -:  940:    case mine:
    #####:  941:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  942:
    #####:  943:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  944:	{
    #####:  945:	  return -1;
        -:  946:	}
        -:  947:
    #####:  948:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  949:	{
    #####:  950:	  return -1;
        -:  951:	}
        -:  952:
    #####:  953:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  954:	{
    #####:  955:	  return -1;
        -:  956:	}
        -:  957:
    #####:  958:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  959:
        -:  960:      //discard card from hand
    #####:  961:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  962:
        -:  963:      //discard trashed card
    #####:  964:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  965:	{
    #####:  966:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  967:	    {
    #####:  968:	      discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  969:	      break;
        -:  970:	    }
        -:  971:	}
        -:  972:
    #####:  973:      return 0;
        -:  974:
        -:  975:    case remodel:
    #####:  976:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  977:
    #####:  978:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  979:	{
    #####:  980:	  return -1;
        -:  981:	}
        -:  982:
    #####:  983:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  984:
        -:  985:      //discard card from hand
    #####:  986:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  987:
        -:  988:      //discard trashed card
    #####:  989:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  990:	{
    #####:  991:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  992:	    {
    #####:  993:	      discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  994:	      break;
        -:  995:	    }
        -:  996:	}
        -:  997:
        -:  998:
    #####:  999:      return 0;
        -: 1000:
        -: 1001: case baron:
    #####: 1002:      state->numBuys++;//Increase buys by 1!
    #####: 1003:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1004:	int p = 0;//Iterator for hand!
    #####: 1005:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1006:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1007:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1008:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1009:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1010:	    state->discardCount[currentPlayer]++;
    #####: 1011:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1012:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1013:	    }
    #####: 1014:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1015:	    state->handCount[currentPlayer]--;
    #####: 1016:	    card_not_discarded = 0;//Exit the loop
        -: 1017:	  }
    #####: 1018:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
    #####: 1019:	    if(DEBUG) {
        -: 1020:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1021:	      printf("Must gain an estate if there are any\n");
        -: 1022:	    }
    #####: 1023:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1024:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1025:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1026:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1027:		isGameOver(state);
call    0 never executed
        -: 1028:	      }
        -: 1029:	    }
    #####: 1030:	    card_not_discarded = 0;//Exit the loop
        -: 1031:	  }
        -: 1032:
        -: 1033:	  else{
    #####: 1034:	    p++;//Next card
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:
        -: 1039:      else{
    #####: 1040:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1041:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1042:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1043:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1044:	    isGameOver(state);
call    0 never executed
        -: 1045:	  }
        -: 1046:	}
        -: 1047:      }
        -: 1048:
        -: 1049:
    #####: 1050:      return 0;
        -: 1051:
        -: 1052:
        -: 1053:
        -: 1054:    case great_hall:
        -: 1055:      //+1 Card
    #####: 1056:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1057:
        -: 1058:      //+1 Actions
    #####: 1059:      state->numActions++;
        -: 1060:
        -: 1061:      //discard card from hand
    #####: 1062:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1063:      return 0;
        -: 1064:
        -: 1065:    case steward:
    #####: 1066:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1067:	{
        -: 1068:	  //+2 cards
    #####: 1069:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1070:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1071:	}
    #####: 1072:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1073:	{
        -: 1074:	  //+2 coins
    #####: 1075:	  state->coins = state->coins + 2;
        -: 1076:	}
        -: 1077:      else
        -: 1078:	{
        -: 1079:	  //trash 2 cards in hand
    #####: 1080:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1081:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1082:	}
        -: 1083:
        -: 1084:      //discard card from hand
    #####: 1085:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1086:      return 0;
        -: 1087:
        -: 1088:    case tribute:
    #####: 1089:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1090:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1091:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1092:	  state->deckCount[nextPlayer]--;
        -: 1093:	}
    #####: 1094:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1095:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1096:	  state->discardCount[nextPlayer]--;
        -: 1097:	}
        -: 1098:	else{
        -: 1099:	  //No Card to Reveal
    #####: 1100:	  if (DEBUG){
        -: 1101:	    printf("No cards to reveal\n");
        -: 1102:	  }
        -: 1103:	}
        -: 1104:      }
        -: 1105:
        -: 1106:      else{
    #####: 1107:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1108:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1109:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1110:	    state->deckCount[nextPlayer]++;
    #####: 1111:	    state->discard[nextPlayer][i] = -1;
    #####: 1112:	    state->discardCount[nextPlayer]--;
        -: 1113:	  }
        -: 1114:
    #####: 1115:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1116:	}
    #####: 1117:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1118:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1119:	state->deckCount[nextPlayer]--;
    #####: 1120:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1121:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1122:	state->deckCount[nextPlayer]--;
        -: 1123:      }
        -: 1124:
    #####: 1125:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
branch  0 never executed
branch  1 never executed
    #####: 1126:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1127:	state->playedCardCount++;
    #####: 1128:	tributeRevealedCards[1] = -1;
        -: 1129:      }
        -: 1130:
    #####: 1131:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1132:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1133:	  state->coins += 2;
        -: 1134:	}
        -: 1135:
    #####: 1136:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1137:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1138:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1139:	}
        -: 1140:	else{//Action Card
    #####: 1141:	  state->numActions = state->numActions + 2;
        -: 1142:	}
        -: 1143:      }
        -: 1144:
    #####: 1145:      return 0;
        -: 1146:
        -: 1147:    case ambassador:
    #####: 1148:      j = 0;		//used to check if player has enough cards to discard
        -: 1149:
    #####: 1150:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1151:	{
    #####: 1152:	  return -1;
        -: 1153:	}
        -: 1154:
    #####: 1155:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1156:	{
    #####: 1157:	  return -1;
        -: 1158:	}
        -: 1159:
    #####: 1160:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1161:	{
    #####: 1162:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1163:	    {
    #####: 1164:	      j++;
        -: 1165:	    }
        -: 1166:	}
    #####: 1167:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1168:	{
    #####: 1169:	  return -1;
        -: 1170:	}
        -: 1171:
    #####: 1172:      if (DEBUG)
        -: 1173:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1174:
        -: 1175:      //increase supply count for choosen card by amount being discarded
    #####: 1176:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1177:
        -: 1178:      //each other player gains a copy of revealed card
    #####: 1179:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1180:	{
    #####: 1181:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1182:	    {
    #####: 1183:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1184:	    }
        -: 1185:	}
        -: 1186:
        -: 1187:      //discard played card from hand
    #####: 1188:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1189:
        -: 1190:      //trash copies of cards returned to supply
    #####: 1191:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1192:	{
    #####: 1193:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1194:	    {
    #####: 1195:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1196:		{
    #####: 1197:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1198:		  break;
        -: 1199:		}
        -: 1200:	    }
        -: 1201:	}
        -: 1202:
    #####: 1203:      return 0;
        -: 1204:
        -: 1205:    case cutpurse:
        -: 1206:
    #####: 1207:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1208:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1209:	{
    #####: 1210:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1211:	    {
    #####: 1212:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1213:		{
    #####: 1214:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1215:		    {
    #####: 1216:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1217:		      break;
        -: 1218:		    }
    #####: 1219:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1220:		    {
    #####: 1221:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1222:			{
    #####: 1223:			  if (DEBUG)
        -: 1224:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1225:			}
    #####: 1226:		      break;
        -: 1227:		    }
        -: 1228:		}
        -: 1229:
        -: 1230:	    }
        -: 1231:
        -: 1232:	}
        -: 1233:
        -: 1234:      //discard played card from hand
    #####: 1235:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1236:
    #####: 1237:      return 0;
        -: 1238:
        -: 1239:
        -: 1240:    case embargo:
        -: 1241:      //+2 Coins
    #####: 1242:      state->coins = state->coins + 2;
        -: 1243:
        -: 1244:      //see if selected pile is in play
    #####: 1245:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1246:	{
    #####: 1247:	  return -1;
        -: 1248:	}
        -: 1249:
        -: 1250:      //add embargo token to selected supply pile
    #####: 1251:      state->embargoTokens[choice1]++;
        -: 1252:
        -: 1253:      //trash card
    #####: 1254:      discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1255:      return 0;
        -: 1256:
        -: 1257:    case outpost:
        -: 1258:      //set outpost flag
    #####: 1259:      state->outpostPlayed++;
        -: 1260:
        -: 1261:      //discard card
    #####: 1262:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1263:      return 0;
        -: 1264:
        -: 1265:    case salvager:
        -: 1266:      //+1 buy
    #####: 1267:      state->numBuys++;
        -: 1268:
    #####: 1269:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1270:	{
        -: 1271:	  //gain coins equal to trashed card
    #####: 1272:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1273:	  //trash card
    #####: 1274:	  discardCard(choice1, currentPlayer, state, 1);
call    0 never executed
        -: 1275:	}
        -: 1276:
        -: 1277:      //discard card
    #####: 1278:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1279:      return 0;
        -: 1280:
        -: 1281:    case sea_hag:
    #####: 1282:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1283:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1284:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1285:	  state->discardCount[i]++;
    #####: 1286:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1287:	}
        -: 1288:      }
    #####: 1289:      return 0;
        -: 1290:
        -: 1291:    case treasure_map:
        -: 1292:      //search hand for another treasure_map
    #####: 1293:      index = -1;
    #####: 1294:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1295:	{
    #####: 1296:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1297:	    {
    #####: 1298:	      index = i;
    #####: 1299:	      break;
        -: 1300:	    }
        -: 1301:	}
    #####: 1302:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1303:	{
        -: 1304:	  //trash both treasure cards
    #####: 1305:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1306:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1307:
        -: 1308:	  //gain 4 Gold cards
    #####: 1309:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1310:	    {
    #####: 1311:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1312:	    }
        -: 1313:
        -: 1314:	  //return success
    #####: 1315:	  return 1;
        -: 1316:	}
        -: 1317:
        -: 1318:      //no second treasure_map found in hand
    #####: 1319:      return -1;
        -: 1320:    }
        -: 1321:
    #####: 1322:  return -1;
        -: 1323:}
        -: 1324:
function discardCard called 2252 returned 100% blocks executed 75%
     2252: 1325:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1326:{
        -: 1327:
        -: 1328:  //if card is not trashed, added to Played pile
     2252: 1329:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1330:    {
        -: 1331:      //add card to played pile
     2252: 1332:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
     2252: 1333:      state->playedCardCount++;
        -: 1334:    }
        -: 1335:
        -: 1336:  //set played card to -1
     2252: 1337:  state->hand[currentPlayer][handPos] = -1;
        -: 1338:
        -: 1339:  //remove card from player's hand
     2252: 1340:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1341:    {
        -: 1342:      //reduce number of cards in hand
    #####: 1343:      state->handCount[currentPlayer]--;
        -: 1344:    }
     2252: 1345:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1346:    {
        -: 1347:      //reduce number of cards in hand
    #####: 1348:      state->handCount[currentPlayer]--;
        -: 1349:    }
        -: 1350:  else
        -: 1351:    {
        -: 1352:      //replace discarded card with last card in hand
     2252: 1353:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1354:      //set last card to -1
     2252: 1355:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1356:      //reduce number of cards in hand
     2252: 1357:      state->handCount[currentPlayer]--;
        -: 1358:    }
        -: 1359:
     2252: 1360:  return 0;
        -: 1361:}
        -: 1362:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1363:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1364:{
        -: 1365:  //Note: supplyPos is enum of choosen card
        -: 1366:
        -: 1367:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1368:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1369:    {
    #####: 1370:      return -1;
        -: 1371:    }
        -: 1372:
        -: 1373:  //added card for [whoseTurn] current player:
        -: 1374:  // toFlag = 0 : add to discard
        -: 1375:  // toFlag = 1 : add to deck
        -: 1376:  // toFlag = 2 : add to hand
        -: 1377:
    #####: 1378:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1379:    {
    #####: 1380:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1381:      state->deckCount[player]++;
        -: 1382:    }
    #####: 1383:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1384:    {
    #####: 1385:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1386:      state->handCount[player]++;
        -: 1387:    }
        -: 1388:  else
        -: 1389:    {
    #####: 1390:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1391:      state->discardCount[player]++;
        -: 1392:    }
        -: 1393:
        -: 1394:  //decrease number in supply pile
    #####: 1395:  state->supplyCount[supplyPos]--;
        -: 1396:
    #####: 1397:  return 0;
        -: 1398:}
        -: 1399:
function updateCoins called 53 returned 100% blocks executed 100%
       53: 1400:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1401:{
        -: 1402:  int i;
        -: 1403:
        -: 1404:  //reset coin count
       53: 1405:  state->coins = 0;
        -: 1406:
        -: 1407:  //add coins for each Treasure card in player's hand
      318: 1408:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1409:    {
      265: 1410:      if (state->hand[player][i] == copper)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -: 1411:	{
      174: 1412:	  state->coins += 1;
        -: 1413:	}
       91: 1414:      else if (state->hand[player][i] == silver)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 1415:	{
       30: 1416:	  state->coins += 2;
        -: 1417:	}
       61: 1418:      else if (state->hand[player][i] == gold)
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -: 1419:	{
       30: 1420:	  state->coins += 3;
        -: 1421:	}
        -: 1422:    }
        -: 1423:
        -: 1424:  //add bonus
       53: 1425:  state->coins += bonus;
        -: 1426:
       53: 1427:  return 0;
        -: 1428:}
        -: 1429:
        -: 1430:
        -: 1431://end of dominion.c
        -: 1432:
