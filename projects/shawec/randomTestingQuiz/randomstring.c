The goal of my functions were to work smarter not harder, by itterating through all options, in the least amount of time. In order to do this, I was able to create arrays with on the needed charachters. So for the inputChar(), it was {'[', '(', '{', ' ', 'a', 'x', '}', ')', ']'}, and then for inputString() I only used {'r', 'e', 's', 't'} to avoid the duplicate e in the array. This also reduced the nummber of possible itterations to about half. When testing, the average point it hit state 9 was around 50 itterations, and then I saw it produce the error code at around 100 at the minimum and around 2000 at maximum.
While I could have just as easily created a random tester that would test every possible char and string, that would have taken forever, would have possibly made our counter loop back around, and then it just wasn't practicle for this sort of situation. We only need to test the certain inputs, because the cases only account for those inputs. Using any other case would be impractical, and doesn't provide any more code coverage. I tested the coverage for this and it still produces 100% for the testme() function, which I would say is a relative success. Not to mention, other than the actual statement that exits the program, it ran each line of the testme() function multiple times.